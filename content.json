{"meta":{"title":"ZZ","subtitle":"ZZのBlog","description":"研究僧 | 计算机技术  ","author":"XZ","url":"http://Inactionzz.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-05-31T03:00:34.021Z","comments":true,"path":"404.html","permalink":"http://inactionzz.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-05-31T03:00:34.170Z","updated":"2021-05-31T03:00:34.170Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://inactionzz.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"","date":"2021-05-31T03:00:34.167Z","updated":"2021-05-31T03:00:34.167Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://inactionzz.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-05-31T03:00:34.039Z","comments":true,"path":"List/index.html","permalink":"http://inactionzz.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-05-31T03:00:34.166Z","comments":true,"path":"about/index.html","permalink":"http://inactionzz.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-05-31T03:00:34.167Z","comments":true,"path":"archives/index.html","permalink":"http://inactionzz.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-05-31T03:00:34.168Z","comments":true,"path":"census/index.html","permalink":"http://inactionzz.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-05-31T11:12:14.218Z","comments":true,"path":"contact/index.html","permalink":"http://inactionzz.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-05-31T03:00:34.168Z","comments":true,"path":"categories/index.html","permalink":"http://inactionzz.github.io/categories/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-05-31T03:00:34.171Z","comments":true,"path":"resource/index.html","permalink":"http://inactionzz.github.io/resource/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-05-31T03:00:34.170Z","comments":true,"path":"friends/index.html","permalink":"http://inactionzz.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-05-31T03:00:34.171Z","comments":true,"path":"tags/index.html","permalink":"http://inactionzz.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-05-31T03:00:34.029Z","updated":"2021-05-31T03:00:34.029Z","comments":true,"path":"List/galleries/index.html","permalink":"http://inactionzz.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-05-31T03:00:34.040Z","comments":true,"path":"List/music/index.html","permalink":"http://inactionzz.github.io/List/music/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-05-31T03:00:34.040Z","comments":true,"path":"List/movies/index.html","permalink":"http://inactionzz.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-05-31T03:00:34.042Z","comments":true,"path":"List/tools/index.html","permalink":"http://inactionzz.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-05-31T03:00:34.030Z","updated":"2021-05-31T03:00:34.030Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-05-31T03:00:34.030Z","updated":"2021-05-31T03:00:34.030Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-05-31T03:00:34.031Z","updated":"2021-05-31T03:00:34.031Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-05-31T03:00:34.032Z","updated":"2021-05-31T03:00:34.032Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-05-31T03:00:34.033Z","updated":"2021-05-31T03:00:34.033Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-05-31T03:00:34.034Z","updated":"2021-05-31T03:00:34.034Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-05-31T03:00:34.035Z","updated":"2021-05-31T03:00:34.035Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-05-31T03:00:34.036Z","updated":"2021-05-31T03:00:34.036Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-05-31T03:00:34.037Z","updated":"2021-05-31T03:00:34.037Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-05-31T03:00:34.037Z","updated":"2021-05-31T03:00:34.037Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-05-31T03:00:34.038Z","updated":"2021-05-31T03:00:34.038Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-05-31T03:00:34.038Z","updated":"2021-05-31T03:00:34.038Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"nlp","slug":"nlp","date":"2022-01-10T13:32:20.000Z","updated":"2022-01-21T10:51:11.407Z","comments":true,"path":"posts/4b4516a4.html","link":"","permalink":"http://inactionzz.github.io/posts/4b4516a4.html","excerpt":"","text":"人工智能研究主要解决的问题 预测性建模 主要目的：在给定数据的基础上提升预测模型的准确率 绝大多数人工智能的应用在很大程度上均可以认为是预测性建模的范畴 区别:预测性建模和统计学：预测性建模只关注模型预测的准确性，统计学模型只关注模型的可解释性。 优化问题 优化问题是指如何根据已有的数学模型求出最优解的过程 近年来取得主要进展的优化问题主要在于增强学习领域 解决的问题：如何在动态环境下做出正确的决定 主要应用：游戏AI 其他应用：内容推荐、搜索排名、智能化定价 人工智能数据的分类 结构化数据 非结构化数据 文本数据 图像，视频数据 语音数据 机器学习和深度学习的区别 区别1：特征提取 机器学习需要有人工的特征提取的过程 深度学习没有复杂的人工特征提取的过程可以通过深度神经网络自动完成 区别2：数据量 机器学习数据少，深度学习需要大量的训练数据集，会有更高的效果 深度学习训练深度神经网络需要大量的算力，因为其中有更多的参数。 神经网络概念英语：Artificial Neural Network，ANN），简称神经网络（Neural Network，NN）或类神经网络，是一种模仿生物神经网络（动物的中枢神经系统，特别是大脑）的结构和功能的数学模型，用于对函数进行估计或近似。 神经元 神经网络的基本单元，相互连接组成神经网络。 公式表达：$$t = f(W^TA+b)$$ $a_1,a_2\\dots a_n​$ 为各个输入的分量 $w_1,w_2 \\cdots w_n$ 为各个输入分量对应的权重参数 $b$ 为偏置 $f$ 为激活函数，常见的激活函数有tanh，sigmoid，relu $t$ 为神经元的输出可见，** 一个神经元的功能是求得输入向量与权向量的内积后，经一个非线性传递函数得到一个标量结果 **。 单层神经网络是最基本的神经元网络形式，由有限个神经元构成，所有神经元的输入向量都是同一个向量。由于每一个神经元都会产生一个标量结果，所以单层神经元的输出是一个向量，向量的维数等于神经元的数目。 感知机感知机由两层神经网络组成，输入层接收外界输入信号后传递给**输出层（输出正例或反例），输出层为M-P神经网络 其中从$w_0,w_1\\cdots w_n​$都表示权重 感知机的作用： 把一个n维向量空间用一个超平面分割成两部分，给定一个输入向量，超平面可以判断出这个向量位于超平面的哪一边，得到输入时正类或者是反类，对应到2维空间就是一条直线把一个平面分为两个部分不可为曲线。 多层神经网络多层神经网络就是由单层神经网络进行叠加之后得到的，所以就形成了层的概念，常见的多层神经网络有如下结构： 输入层（Input layer），众多神经元（Neuron）接受大量输入消息。输入的消息称为输入向量。 输出层（Output layer），消息在神经元链接中传输、分析、权衡，形成输出结果。输出的消息称为输出向量。 隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。隐层可以有一层或多层。隐层的节点（神经元）数目不定，但数目越多神经网络的非线性越显著，从而神经网络的强健性（robustness）更显著。示意图： 概念：全连接层简单的说即进行$$y=Wx+b$$变换 全连接层：当前一层和前一层每个神经元相互链接，我们称当前这一层为全连接层。 重点：假设第N-1层有m个神经元，第N层有n个神经元，经过矩阵运算可以由m个神经元转换成n 从上图可以看出，所谓的全连接层就是在前一层的输出的基础上进行一次$Y=Wx+b​$的变化(不考虑激活函数的情况下就是一次线性变化，所谓线性变化就是平移(+b)和缩放的组合(*w)) 激活函数 如上图，右边是sigmoid函数，对感知机的结果，通过sigmoid函数进行处理 如果给定合适的参数w和b，就可以得到合适的曲线，能够完成对最开始问题的非线性分割 所以激活函数很重要的一个作用就是增加模型的非线性分割能力,便于拟合曲线常用的激活函数有： 可知： sigmoid 只会输出正数，以及靠近0的输出变化率最大 tanh和sigmoid不同的是，tanh输出可以是负数 Relu是输入只能大于0,如果你输入含有负数，Relu就不适合，如果你的输入是图片格式，Relu就挺常用的，因为图片的像素值作为输入时取值为[0,255]。 激活函数的作用除了前面说的增加模型的非线性分割能力外，还有 提高模型鲁棒性 缓解梯度消失问题 加速模型收敛等 例子：通过较低级输入，进行更高级特征的学习，最终得到输出。 总结：深度学习的思想：输入最原始的最基本的数据，通过模型来进行特征工程，然后进行更加高级的特征工程的学习，通过输入的数据来确定合适的参数，让模型去更好的拟合数据。这个过程可以理解为盲人摸象，多个人一起摸，把摸到的结果乘上合适的权重，进行合适的变化，让他和目标值趋近一致。整个过程只需要输入基础的数据，程序自动寻找合适的参数。 pytorch1.张量tensor张量是一个统称，其中包含很多类型： 0阶张量：标量、常数，0-D Tensor 1阶张量：向量，1-D Tensor 2阶张量：矩阵，2-D Tensor 3阶张量 … N阶张量 2. Pytorch中创建张量 使用python中的列表或者序列创建tensor torch.tensor([[1., -1.], [1., -1.]]) tensor([[ 1.0000, -1.0000], [ 1.0000, -1.0000]]) 使用numpy中的数组创建tensor torch.tensor(np.array([[1, 2, 3], [4, 5, 6]])) tensor([[ 1, 2, 3], [ 4, 5, 6]]) 使用torch的api创建tensor torch.empty(3,4)创建3行4列的空的tensor，会用无用数据进行填充 torch.ones([3,4]) 创建3行4列的全为1的tensor torch.zeros([3,4])创建3行4列的全为0的tensor torch.rand([3,4]) 创建3行4列的随机值的tensor，随机值的区间是[0, 1) &gt;&gt;&gt; torch.rand(2, 3) tensor([[ 0.8237, 0.5781, 0.6879], [ 0.3816, 0.7249, 0.0998]]) torch.randint(low=0,high=10,size=[3,4]) 创建3行4列的随机整数的tensor，随机值的区间是[low, high) &gt;&gt;&gt; torch.randint(3, 10, (2, 2)) tensor([[4, 5], [6, 7]]) torch.randn([3,4]) 创建3行4列的随机数的tensor，随机值的分布式均值为0，方差为1 pytorch中的tensor中的常用方法 获取tensor中的数据(当tensor中只有一个元素可用)：tensor.item() In [10]: a = torch.tensor(np.arange(1)) In [11]: a Out[11]: tensor([0]) In [12]: a.item() Out[12]: 0 转化为numpy数组 In [55]: z.numpy() Out[55]: array([[-2.5871205], [ 7.3690367], [-2.4918075]], dtype=float32) 获取形状：tensor.size() In [72]: x Out[72]: tensor([[ 1, 2], [ 3, 4], [ 5, 10]], dtype=torch.int32) In [73]: x.size() Out[73]: torch.Size([3, 2]) 形状改变：tensor.view((3,4))。类似numpy中的reshape，是一种浅拷贝，仅仅是形状发生改变 In [76]: x.view(2,3) Out[76]: tensor([[ 1, 2, 3], [ 4, 5, 10]], dtype=torch.int32) 获取阶数：tensor.dim() In [77]: x.dim() Out[77]: 2 获取最大值：tensor.max() In [78]: x.max() Out[78]: tensor(10, dtype=torch.int32) 转置：tensor.t() In [79]: x.t() Out[79]: tensor([[ 1, 3, 5], [ 2, 4, 10]], dtype=torch.int32) tensor[1,3] 获取tensor中第一行第三列的值 tensor[1,3]=100 对tensor中第一行第三列的位置进行赋值100 tensor的切片 In [101]: x Out[101]: tensor([[1.6437, 1.9439, 1.5393], [1.3491, 1.9575, 1.0552], [1.5106, 1.0123, 1.0961], [1.4382, 1.5939, 1.5012], [1.5267, 1.4858, 1.4007]]) In [102]: x[:,1] Out[102]: tensor([1.9439, 1.9575, 1.0123, 1.5939, 1.4858]) ``` ​ ### 4. tensor的数据类型 tensor中的数据类型非常多，常见类型如下： ![](nlp/images/1.2/tensor的数据类型.png) 上图中的Tensor types表示这种type的tensor是其实例 1. 获取tensor的数据类型:`tensor.dtype` ```python In [80]: x.dtype Out[80]: torch.int32 创建数据的时候指定类型 In [88]: torch.ones([2,3],dtype=torch.float32) Out[88]: tensor([[9.1167e+18, 0.0000e+00, 7.8796e+15], [8.3097e-43, 0.0000e+00, -0.0000e+00]]) 类型的修改 In [17]: a Out[17]: tensor([1, 2], dtype=torch.int32) In [18]: a.type(torch.float) Out[18]: tensor([1., 2.]) In [19]: a.double() Out[19]: tensor([1., 2.], dtype=torch.float64) 5. tensor的其他操作 tensor和tensor相加 In [94]: x = x.new_ones(5, 3, dtype=torch.float) In [95]: y = torch.rand(5, 3) In [96]: x+y Out[96]: tensor([[1.6437, 1.9439, 1.5393], [1.3491, 1.9575, 1.0552], [1.5106, 1.0123, 1.0961], [1.4382, 1.5939, 1.5012], [1.5267, 1.4858, 1.4007]]) In [98]: torch.add(x,y) Out[98]: tensor([[1.6437, 1.9439, 1.5393], [1.3491, 1.9575, 1.0552], [1.5106, 1.0123, 1.0961], [1.4382, 1.5939, 1.5012], [1.5267, 1.4858, 1.4007]]) In [99]: x.add(y) Out[99]: tensor([[1.6437, 1.9439, 1.5393], [1.3491, 1.9575, 1.0552], [1.5106, 1.0123, 1.0961], [1.4382, 1.5939, 1.5012], [1.5267, 1.4858, 1.4007]]) In [100]: x.add_(y) #带下划线的方法会对x进行就地修改 Out[100]: tensor([[1.6437, 1.9439, 1.5393], [1.3491, 1.9575, 1.0552], [1.5106, 1.0123, 1.0961], [1.4382, 1.5939, 1.5012], [1.5267, 1.4858, 1.4007]]) In [101]: x #x发生改变 Out[101]: tensor([[1.6437, 1.9439, 1.5393], [1.3491, 1.9575, 1.0552], [1.5106, 1.0123, 1.0961], [1.4382, 1.5939, 1.5012], [1.5267, 1.4858, 1.4007]]) 注意：带下划线的方法（比如:add_)会对tensor进行就地修改 tensor和数字操作 In [97]: x +10 Out[97]: tensor([[11., 11., 11.], [11., 11., 11.], [11., 11., 11.], [11., 11., 11.], [11., 11., 11.]]) CUDA中的tensor CUDA（Compute Unified Device Architecture），是NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 torch.cuda这个模块增加了对CUDA tensor的支持，能够在cpu和gpu上使用相同的方法操作tensor 通过.to方法能够把一个tensor转移到另外一个设备(比如从CPU转到GPU) #device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\") if torch.cuda.is_available(): device = torch.device(\"cuda\") # cuda device对象 y = torch.ones_like(x, device=device) # 创建一个在cuda上的tensor x = x.to(device) # 使用方法把x转为cuda 的tensor z = x + y print(z) print(z.to(\"cpu\", torch.double)) # .to方法也能够同时设置类型 &gt;&gt;tensor([1.9806], device='cuda:0') &gt;&gt;tensor([1.9806], dtype=torch.float64) ``` 总结：torch中的许多操作基本与numpy的一样 ## 梯度下降和反向传播 ### 梯度 梯度：是一个向量，导数+变化最快的方向(学习的前进方向)---梯度就是多元函数参数的变化趋势（参数学习的方向），只有一个自变量时称为**导数** ### 偏导的计算 1. 常见的导数计算 2. 多元函数求偏导 ### 反向传播算法 #### 计算图和反向传播 计算图：通过图的方式来描述函数的图形 在上面的练习中，$J(a,b,c) = 3(a+bc),令u=a+v,v = bc$,把它绘制成计算图可以表示为： ![](nlp/images/1.2/计算图.png) 绘制成为计算图之后，可以清楚的看到向前计算的过程 之后，对每个节点求偏导可有： ![](nlp/images/1.2/计算梯度.png) 那么反向传播的过程就是一个上图的从右往左的过程，自变量$a,b,c$各自的偏导就是连线上的梯度的乘积： $$ \\begin{align*} \\frac{dJ}{da} &amp;= 3 \\times 1 \\\\ \\frac{dJ}{db} &amp;= 3 \\times 1 \\times c \\\\ \\frac{dJ}{dc} &amp;= 3 \\times 1 \\times b \\end{align*} $$ ### 神经网络中的反向传播 反向传播的思想就是对其中的某一个参数单独求梯度，之后更新，如下图所示： ![](nlp/images/1.2/偏导的计算2.png) ## Pytorch完成线性回归 ### 1.向前计算 对于pytorch中的一个tensor，如果设置它的属性 `.requires_grad`为`True`，那么它将会追踪对于该张量的所有操作。或者可以理解为，这个tensor是一个参数，后续会被计算梯度，更新该参数。 #### 1.1 计算过程 假设有以下条件（1/4表示求均值，xi中有4个数），使用torch完成其向前计算的过程 $$ \\begin{align*} &amp;o = \\frac{1}{4}\\sum_iz_i \\\\ &amp;z_i = 3(x_i+2)^2\\\\ 其中:&amp;\\\\ &amp;z_i|_{x_i=1}=27\\\\ \\end{align*} $$ 如果x为参数，需要对其进行梯度的计算和更新 那么，在最开始随机设置x的值的过程中，需要设置他的requires_grad属性为True，其**默认值为False** ```python import torch x = torch.ones(2, 2, requires_grad=True) #初始化参数x并设置requires_grad=True用来追踪其计算历史 print(x) #tensor([[1., 1.], # [1., 1.]], requires_grad=True) y = x+2 print(y) #tensor([[3., 3.], # [3., 3.]], grad_fn=&lt;AddBackward0&gt;) z = y*y*3 #平方x3 print(x) #tensor([[27., 27.], # [27., 27.]], grad_fn=&lt;MulBackward0&gt;) out = z.mean() #求均值 print(out) #tensor(27., grad_fn=&lt;MeanBackward0&gt;) 从上述代码可以看出： x的requires_grad属性为True 之后的每次计算都会修改其grad_fn属性，用来记录做过的操作 通过这个函数和grad_fn能够组成一个和类似的计算图 1.2 requires_grad和grad_fna = torch.randn(2, 2) a = ((a * 3) / (a - 1)) print(a.requires_grad) #False a.requires_grad_(True) #就地修改 print(a.requires_grad) #True b = (a * a).sum() print(b.grad_fn) # &lt;SumBackward0 object at 0x4e2b14345d21&gt; with torch.no_gard(): c = (a * a).sum() #tensor(151.6830),此时c没有gard_fn print(c.requires_grad) #False 注意： 为了防止跟踪历史记录（和使用内存），可以将代码块包装在with torch.no_grad():中。在评估模型时特别有用，因为模型可能具有requires_grad = True的可训练的参数，但是我们不需要在此过程中对他们进行梯度计算。 2. 梯度计算对于1.1 中的out而言，我们可以使用backward方法来进行反向传播，计算梯度 out.backward(),此时便能够求出导数$\\frac{d out}{dx}$,调用x.gard能够获取导数值 得到 tensor([[4.5000, 4.5000], [4.5000, 4.5000]]) 因为：$$\\frac{d(O)}{d(x_i)} = \\frac{3}{2}(x_i+2)$$在$x_i$等于1时其值为4.5 注意：在输出为一个标量的情况下，可以调用输出tensor的backword() 方法，但是在数据是一个向量的时候，调用backward()的时候还需要传入其他参数。 很多时候我们的损失函数都是一个标量。 loss.backward()就是根据损失函数，对参数（requires_grad=True） 去计算他的梯度，并且把它累加保存到x.gard，此时还并未更新其梯度，需要先更新为0后进行后续的操作。 注意点： tensor.data: 在tensor的require_grad=False，tensor.data和tensor等价 require_grad=True时，tensor.data仅仅是获取tensor中的数据 tensor.numpy(): require_grad=True不能够直接转换，需要使用tensor.detach().numpy() 3. 线性回归实现下面，我们使用一个自定义的数据，来使用torch实现一个简单的线性回归 假设我们的基础模型就是y = wx+b，其中w和b均为参数，我们使用y = 3x+0.8来构造数据x、y，所以最后通过模型应该能够得出w和b应该分别接近3和0.8 准备数据 计算预测值 计算损失，把参数的梯度置为0，进行反向传播 更新参数 import torch import numpy as np from matplotlib import pyplot as plt #1. 准备数据 y = 3x+0.8，准备参数 x = torch.rand([50]) y = 3*x + 0.8 w = torch.rand(1,requires_grad=True) b = torch.rand(1,requires_grad=True) def loss_fn(y,y_predict): loss = (y_predict-y).pow(2).mean() for i in [w,b]: #每次反向传播前把梯度置为0 if i.grad is not None: i.grad.data.zero_() # [i.grad.data.zero_() for i in [w,b] if i.grad is not None] loss.backward() return loss.data def optimize(learning_rate): # print(w.grad.data,w.data,b.data) w.data -= learning_rate* w.grad.data b.data -= learning_rate* b.grad.data for i in range(3000): #2. 计算预测值 y_predict = x*w + b #3.计算损失，把参数的梯度置为0，进行反向传播 loss = loss_fn(y,y_predict) if i%500 == 0: print(i,loss) #4. 更新参数w和b optimize(0.01) # 绘制图形，观察训练结束的预测值和真实值 predict = x*w + b #使用训练后的w和b计算预测值 plt.scatter(x.data.numpy(), y.data.numpy(),c = \"r\") plt.plot(x.data.numpy(), predict.data.numpy()) plt.show() print(\"w\",w) print(\"b\",b) 图形效果如下： 打印w和b，可有 w tensor([2.9280], requires_grad=True) b tensor([0.8372], requires_grad=True) 可知，w和b已经非常接近原来的预设的3和0.8,end Pytorch完成基础的模型1. Pytorch完成模型常用API在pytorch中预设了一些更加灵活简单的对象，让我们来构造模型、定义损失，优化损失等更加的方便。 1.1 nn.Modulenn.Modul 是torch.nn提供的一个类，是pytorch中我们自定义网络的一个基类，在这个类中定义了很多有用的方法，让我们在继承这个类定义网络的时候非常简单 当我们自定义网络的时候，有两个方法需要特别注意： __init__需要调用super方法，继承父类的属性和方法 farward方法必须实现，用来定义我们的网络的向前计算的过程 用y = wx+b的模型举例如下： from torch import nn class Lr(nn.Module): def __init__(self): super(Lr, self).__init__() #继承父类init的参数 self.linear = nn.Linear(1, 1) def forward(self, x): out = self.linear(x) return out 注意： nn.Linear为torch预定义好的线性模型，也被称为全链接层，传入的参数为输入的数量，输出的数量(in_features, out_features),是不算(batch_size的列数) nn.Module定义了__call__方法，实现的就是调用forward方法，即Lr的实例，能够直接被传入参数调用，实际上调用的是forward方法并传入参数# 实例化模型 model = Lr() # 传入数据，计算结果 predict = model(x) ``` #### 1.2 优化器类 优化器(`optimizer`)，可以理解为torch为我们封装的用来进行更新参数的方法，比如常见的随机梯度下降(`stochastic gradient descent,SGD`) 优化器类都是由`torch.optim`提供的，例如 1. `torch.optim.SGD(参数，学习率)` 2. `torch.optim.Adam(参数，学习率)` 注意： 1. 参数可以使用`model.parameters()`来获取，获取模型中所有`requires_grad=True`的参数 2. 优化类的使用方法 1. 实例化 2. 所有参数的梯度，将其值置为0 3. 反向传播计算梯度 4. 更新参数值 示例如下： ```python optimizer = optim.SGD(model.parameters(), lr=1e-3) #1. 实例化 optimizer.zero_grad() #2. 梯度置为0 loss.backward() #3. 计算梯度 optimizer.step() #4. 更新参数的值 1.3 损失函数 前面的例子是一个回归问题，torch中也预测了很多损失函数 均方误差:nn.MSELoss(),常用于回归问题 交叉熵损失：nn.CrossEntropyLoss()，常用于分类问题 使用方法： model = Lr() #1. 实例化模型 criterion = nn.MSELoss() #2. 实例化损失函数 optimizer = optim.SGD(model.parameters(), lr=1e-3) #3. 实例化优化器类 for i in range(100): y_predict = model(x_true) #4. 向前计算预测值 loss = criterion(y_true,y_predict) #5. 调用损失函数传入真实值和预测值，得到损失结果 optimizer.zero_grad() #5. 当前循环参数梯度置为0 loss.backward() #6. 计算梯度 optimizer.step() #7. 更新参数的值 1.4 把线性回归完整代码import torch from torch import nn from torch import optim import numpy as np from matplotlib import pyplot as plt # 1. 定义数据 x = torch.rand([50,1]) y = x*3 + 0.8 #2 .定义模型 class Lr(nn.Module): def __init__(self): super(Lr,self).__init__() self.linear = nn.Linear(1,1) def forward(self, x): out = self.linear(x) return out # 2. 实例化模型，loss，和优化器 model = Lr() criterion = nn.MSELoss() optimizer = optim.SGD(model.parameters(), lr=1e-3) #3. 训练模型 for i in range(30000): out = model(x) #3.1 获取预测值 loss = criterion(y,out) #3.2 计算损失 optimizer.zero_grad() #3.3 梯度归零 loss.backward() #3.4 计算梯度 optimizer.step() # 3.5 更新梯度 if (i+1) % 20 == 0: print('Epoch[{}/{}], loss: {:.6f}'.format(i,30000,loss.data)) #4. 模型评估 model.eval() #设置模型为评估模式，即预测模式 predict = model(x) predict = predict.data.numpy() plt.scatter(x.data.numpy(),y.data.numpy(),c=\"r\") plt.plot(x.data.numpy(),predict) plt.show() 输出如下： 注意： model.eval()表示设置模型为评估模式，即预测模式 model.train(mode=True) 表示设置模型为训练模式 在当前的线性回归中，上述并无区别 但是在其他的一些模型中，训练的参数和预测的参数会不相同，到时候就需要具体告诉程序我们是在进行训练还是预测，比如模型中存在Dropout，BatchNorm的时候 2. 在GPU上运行代码当模型太大，或者参数太多的情况下，为了加快训练速度，经常会使用GPU来进行训练 此时我们的代码需要稍作调整： 判断GPU是否可用torch.cuda.is_available() torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\") &gt;&gt;device(type='cuda', index=0) #使用gpu &gt;&gt;device(type='cpu') #使用cpu 把模型参数和input数据转化为cuda的支持类型 model.to(device) x_true.to(device) 在GPU上计算结果也为cuda的数据类型，需要转化为numpy或者torch的cpu的tensor类型 predict = predict.cpu().detach().numpy() detach()的效果和data的相似，但是detach()是深拷贝，data是取值，是浅拷贝 修改之后的代码如下： import torch from torch import nn from torch import optim import numpy as np from matplotlib import pyplot as plt import time # 1. 定义数据 x = torch.rand([50,1]) y = x*3 + 0.8 #2 .定义模型 class Lr(nn.Module): def __init__(self): super(Lr,self).__init__() self.linear = nn.Linear(1,1) def forward(self, x): out = self.linear(x) return out # 2. 实例化模型，loss，和优化器 device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\") x,y = x.to(device),y.to(device) model = Lr().to(device) criterion = nn.MSELoss() optimizer = optim.SGD(model.parameters(), lr=1e-3) #3. 训练模型 for i in range(300): out = model(x) loss = criterion(y,out) optimizer.zero_grad() loss.backward() optimizer.step() if (i+1) % 20 == 0: print('Epoch[{}/{}], loss: {:.6f}'.format(i,30000,loss.data)) #4. 模型评估 model.eval() # predict = model(x) predict = predict.cpu().detach().numpy() #转化为numpy数组 plt.scatter(x.cpu().data.numpy(),y.cpu().data.numpy(),c=\"r\") plt.plot(x.cpu().data.numpy(),predict,) plt.show() 常见的优化算法3.1 梯度下降算法（batch gradient descent BGD）每次迭代都需要把所有样本都送入，这样的好处是每次迭代都顾及了全部的样本，做的是全局最优化,但是有可能达到局部最优。 3.2 随机梯度下降法 (Stochastic gradient descent SGD)针对梯度下降算法训练速度过慢的缺点，提出了随机梯度下降算法，随机梯度下降算法是从样本中随机抽出一组，训练后按梯度更新一次，然后再抽取一组，再更新一次，在样本量及其大的情况下，可能不用训练完所有的样本就可以获得一个损失值在可接受范围之内的模型了。torch中的api为：torch.optim.SGD() 3.3 小批量梯度下降 (Mini-batch gradient descent MBGD）SGD相对来说要快很多，但是也有存在问题，由于单个样本的训练可能会带来很多噪声，使得SGD并不是每次迭代都向着整体最优化方向，因此在刚开始训练时可能收敛得很快，但是训练一段时间后就会变得很慢。在此基础上又提出了小批量梯度下降法，它是每次从样本中随机抽取一小批进行训练，而不是一组，这样即保证了效果又保证的速度。 3.4 动量法mini-batch SGD算法虽然这种算法能够带来很好的训练速度，但是在到达最优点的时候并不能够总是真正到达最优点，而是在最优点附近徘徊。 另一个缺点就是mini-batch SGD需要我们挑选一个合适的学习率，当我们采用小的学习率的时候，会导致网络在训练的时候收敛太慢；当我们采用大的学习率的时候，会导致在训练过程中优化的幅度跳过函数的范围，也就是可能跳过最优点。我们所希望的仅仅是网络在优化的时候网络的损失函数有一个很好的收敛速度同时又不至于摆动幅度太大。 所以Momentum优化器刚好可以解决我们所面临的问题，它主要是基于梯度的移动指数加权平均，对网络的梯度进行平滑处理的，让梯度的摆动幅度变得更小。$$\\begin{align*}&amp;gradent = 0.8\\nabla w + 0.2 history_gradent &amp;，\\nabla w 表示当前一次的梯度\\&amp;w = w - \\alpha* gradent &amp;，\\alpha表示学习率\\end{align*}$$ （注：t+1的的histroy_gradent 为第t次的gradent） 3.5 AdaGradAdaGrad算法就是将每一个参数的每一次迭代的梯度取平方累加后在开方，用全局学习率除以这个数，作为学习率的动态更新，从而达到自适应学习率的效果$$\\begin{align*}&amp;gradent = history_gradent + (\\nabla w)^2 \\&amp;w = w - \\frac{\\alpha}{\\sqrt{gradent}+\\delta} \\nabla w ,&amp;\\delta为小常数，为了数值稳定大约设置为10^{-7}\\end{align*}$$ 3.6 RMSPropMomentum优化算法中，虽然初步解决了优化中摆动幅度大的问题,为了进一步优化损失函数在更新中存在摆动幅度过大的问题，并且进一步加快函数的收敛速度，RMSProp算法对参数的梯度使用了平方加权平均数。$$\\begin{align*}&amp; gradent = 0.8history_gradent + 0.2(\\nabla w)^2 \\&amp; w = w - \\frac{\\alpha}{\\sqrt{gradent}+\\delta} \\nabla w\\end{align*}$$ 3.7 AdamAdam（Adaptive Moment Estimation）算法是将Momentum算法和RMSProp算法结合起来使用的一种算法,能够达到防止梯度的摆幅多大，同时还能够加开收敛速度同时对梯度和学习率进行了限制。学习率能够自适应，梯度的振幅不会过大。$$\\begin{align*}&amp; 1. 需要初始化梯度的累积量和平方累积量 \\&amp; v_w = 0,s_w = 0 \\&amp; 2. 第 t 轮训练中，我们首先可以计算得到Momentum和RMSProp的参数更新：\\&amp; v_w = 0.8v + 0.2 \\nabla w \\qquad,Momentum计算的梯度\\&amp; s_w = 0.8s + 0.2(\\nabla w)^2 \\qquad,RMSProp计算的梯度\\&amp; 3. 对其中的值进行处理后，得到：\\&amp; w = w - \\frac{\\alpha}{\\sqrt{s_w}+\\delta} v_w\\end{align*}$$torch中的api为：torch.optim.Adam() 3.8 效果演示： Pytroch 中的数据加载1. 模型中使用数据加载器的目的在前面的线性回归模型中，我们使用的数据很少，所以直接把全部数据放到模型中去使用。 但是在深度学习中，数据量通常是都非常多，非常大的，如此大量的数据，不可能一次性的在模型中进行向前的计算和反向传播，经常我们会对整个数据进行随机的打乱顺序，把数据处理成一个个的batch，同时还会对数据进行预处理。 所以，接下来我们来学习pytorch中的数据加载的方法 2. 数据集类2.1 Dataset基类介绍在torch中提供了数据集的基类torch.utils.data.Dataset，继承这个基类，我们能够非常快速的实现对数据的加载。 torch.utils.data.Dataset的源码如下： class Dataset(object): \"\"\"An abstract class representing a Dataset. All other datasets should subclass it. All subclasses should override ``__len__``, that provides the size of the dataset, and ``__getitem__``, supporting integer indexing in range from 0 to len(self) exclusive. \"\"\" def __getitem__(self, index): raise NotImplementedError def __len__(self): raise NotImplementedError def __add__(self, other): return ConcatDataset([self, other]) 可知：我们需要在自定义的数据集类中继承Dataset类，同时还需要实现两个方法： __len__方法，能够实现通过全局的len()方法获取其中的元素个数 __getitem__方法，能够通过传入索引的方式获取数据，例如通过dataset[i]获取其中的第i条数据 2.2 数据加载案例下面通过一个例子来看看如何使用Dataset来加载数据 数据来源：http://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection 数据介绍：SMS Spam Collection是用于骚扰短信识别的经典数据集，完全来自真实短信内容，包括4831条正常短信和747条骚扰短信。正常短信和骚扰短信保存在一个文本文件中。 每行完整记录一条短信内容，每行开头通过ham和spam标识正常短信和骚扰短信 数据实例： 实现如下： from torch.utils.data import Dataset,DataLoader import pandas as pd data_path = r\"data\\SMSSpamCollection\" class CifarDataset(Dataset): def __init__(self): lines = open(data_path,\"r\") #对数据进行处理，前4个为label，后面的为短信内容 lines = [[i[:4].strip(),i[4:].strip()] for i in lines] #转化为dataFrame self.df = pd.DataFrame(lines,columns=[\"label\",\"sms\"]) def __getitem__(self, index): single_item = self.df.iloc[index,:] return single_item.values[0],single_item.values[1] def __len__(self): return self.df.shape[0] 之后对Dataset进行实例化，可以跌倒获取其中的数据 d = CifarDataset() for i in range(len(d)): print(i,d[i]) 输出如下： .... 5571 ('ham', 'Pity, * was in mood for that. So...any other suggestions?') 5572 ('ham', \"The guy did some bitching but I acted like i'd be interested in buying something else next week and he gave it to us for free\") 5573 ('ham', 'Rofl. Its true to its name') 3. 迭代数据集使用上述的方法能够进行数据的读取，但是其中还有很多内容没有实现： 批处理数据（Batching the data） 打乱数据（Shuffling the data） 使用多线程 multiprocessing 并行加载数据。 在pytorch中torch.utils.data.DataLoader提供了上述的所用方法 DataLoader的使用方法示例： from torch.utils.data import DataLoader dataset = CifarDataset() data_loader = DataLoader(dataset=dataset,batch_size=10,shuffle=True,num_workers=2) #遍历，获取其中的每个batch的结果 for index, (label, context) in enumerate(data_loader): print(index,label,context) print(\"*\"*100) 其中参数含义： dataset：提前定义的dataset的实例 batch_size:传入数据的batch的大小，常用128,256等等 shuffle：bool类型，表示是否在每次获取数据的时候提前打乱数据 num_workers:加载数据的线程数 数据迭代器的返回结果如下： 555 ('spam', 'ham', 'spam', 'ham', 'ham', 'ham', 'ham', 'spam', 'ham', 'ham') ('URGENT! We are trying to contact U. Todays draw shows that you have won a £800 prize GUARANTEED. Call 09050003091 from....\", 'swhrt how u dey,hope ur ok, tot about u 2day.love n miss.take care.') *********************************************************************************** 556 ('ham', 'ham', 'ham', 'ham', 'ham', 'ham', 'ham', 'ham', 'ham', 'spam') ('He telling not to tell any one. If so treat for me hi hi hi', 'Did u got that persons story', \"Don kn....1000 cash prize or a prize worth £5000') 注意： len(dataset) = 数据集的样本数 len(dataloader) = math.ceil(样本数/batch_size) 即向上取整 4 pytorch自带的数据集pytorch中自带的数据集由两个上层api提供，分别是torchvision和torchtext 其中： torchvision提供了对图片数据处理相关的api和数据 数据位置：torchvision.datasets，例如：torchvision.datasets.MNIST(手写数字图片数据) torchtext提供了对文本数据处理相关的API和数据 数据位置：torchtext.datasets,例如：torchtext.datasets.IMDB（电影评论文本数据） 下面我们以Mnist手写数字为例，来看看pytorch如何加载其中自带的数据集 使用方法和之前一样： 准备好Dataset实例 把dataset交给dataloder 打乱顺序，组成batch 4.1 torchversion.datasetstorchversoin.datasets中的数据集类（比如torchvision.datasets.MNIST）,都是继承自Dataset 意味着：直接对torchvision.datasets.MNIST进行实例化就可以得到Dataset的实例 但是MNIST API中的参数需要注意一下： torchvision.datasets.MNIST(root='/files/', train=True, download=True, transform=) root参数表示数据存放的位置 train：bool类型，表示是使用训练集的数据还是测试集的数据 download：bool类型，表示是否需要下载数据到root目录 transform:实现的对图片的处理函数 4.2 MNIST数据集的介绍数据集的原始地址：http://yann.lecun.com/exdb/mnist/ MNIST是由Yann LeCun等人提供的免费的图像识别的数据集，其中包括60000个训练样本和10000个测试样本，其中图拍了的尺寸已经进行的标准化的处理，都是黑白的图像，大小为28X28 执行代码，下载数据，观察数据类型： import torchvision dataset = torchvision.datasets.MNIST(root=\"./data\",train=True,download=True,transform=None) print(dataset[0]) 下载的数据如下： 代码输出结果如下： Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz Downloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz Downloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz Downloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz Processing... Done! (&lt;PIL.Image.Image image mode=L size=28x28 at 0x18D303B9C18&gt;, tensor(5)) 可以其中数据集返回了两条数据，可以猜测为图片的数据和目标值 返回值的第0个为Image类型，可以调用show() 方法打开，发现为手写数字5 import torchvision dataset = torchvision.datasets.MNIST(root=\"./data\",train=True,download=True,transform=None) print(dataset[0]) img = dataset[0][0] img.show() #打开图片 图片如下： 由上可知：返回值为(图片，目标值),这个结果也可以通过观察源码得到 使用Pytorch实现手写数字识别1.流程流程分析： 准备数据，需要准备DataLoader 构建模型，使用Torch构造一个深层的神经网络 模型的训练 模型保存 模型评估，使用测试集，观察模型的好坏。 2. 准备训练集和测试集准备数据集的方法前面已经讲过，但是通过前面的内容可知，调用MNIST返回的结果中图形数据是一个Image对象,需要对其进行处理 为了进行数据的处理，需要使用torchvision.transfroms的方法 2.1 torchvision.transforms的图形数据处理方法2.1.1 torchvision.transforms.ToTensor把一个取值范围是[0,255]的PIL.Image或者shape为(H,W,C)的numpy.ndarray，转换成形状为[C,H,W] 其中(H,W,C)意思为(高，宽，通道数)，黑白图片的通道数只有1，其中每个像素点的取值为[0,255],彩色图片的通道数为(R,G,B),每个通道的每个像素点的取值为[0,255]，三个通道的颜色相互叠加，形成了各种颜色 示例如下： from torchvision import transforms import numpy as np data = np.random.randint(0, 255, size=12) img = data.reshape(2,2,3) print(img.shape) img_tensor = transforms.ToTensor()(img) # 转换成tensor print(img_tensor) print(img_tensor.shape) 输出如下： shape:(2, 2, 3) img_tensor:tensor([[[215, 171], [ 34, 12]], [[229, 87], [ 15, 237]], [[ 10, 55], [ 72, 204]]], dtype=torch.int32) new shape:torch.Size([3, 2, 2]) 注意： transforms.ToTensor对象中有__call__方法，所以可以对其示例能够传入数据获取结果 2.1.2 torchvision.transforms.Normalize(mean, std)给定均值：mean，shape和图片的通道数相同(指的是每个通道的均值)，方差：std，和图片的通道数相同(指的是每个通道的方差)，将会把Tensor规范化处理。 即：Normalized_image=(image-mean)/std。 例如： from torchvision import transforms import numpy as np import torchvision data = np.random.randint(0, 255, size=12) img = data.reshape(2,2,3) img = transforms.ToTensor()(img) # 转换成tensor print(img) print(\"*\"*100) norm_img = transforms.Normalize((10,10,10), (1,1,1))(img) #进行规范化处理 print(norm_img) 输出如下： tensor([[[177, 223], [ 71, 182]], [[153, 120], [173, 33]], [[162, 233], [194, 73]]], dtype=torch.int32) *************************************************************************************** tensor([[[167, 213], [ 61, 172]], [[143, 110], [163, 23]], [[152, 223], [184, 63]]], dtype=torch.int32) 注意：在sklearn中，默认上式中的std和mean为数据每列的std和mean，sklearn会在标准化之前算出每一列的std和mean。 但是在api：Normalize中并没有帮我们计算，所以我们需要手动计算 当mean为全部数据的均值，std为全部数据的std的时候，才是进行了标准化。 如果mean(x)不是全部数据的mean的时候，std(y)也不是的时候，Normalize后的数据分布满足下面的关系$$\\begin{align*}&amp;new_mean = \\frac{mean-x}{y}&amp;， mean为原数据的均值，x为传入的均值x \\&amp;new_std = \\frac{std}{y} &amp;，y为传入的标准差y\\\\end{align*}$$ 2.1.3 torchvision.transforms.Compose(transforms)将多个transform组合起来使用。 例如 transforms.Compose([ torchvision.transforms.ToTensor(), #先转化为Tensor torchvision.transforms.Normalize(mean,std) #在进行正则化 ]) 2.2 准备MNIST数据集的Dataset和DataLoader准备训练集 import torchvision #准备数据集，其中0.1307，0.3081为MNIST数据的均值和标准差，这样操作能够对其进行标准化 #因为MNIST只有一个通道（黑白图片）,所以元组中只有一个值 dataset = torchvision.datasets.MNIST('/data', train=True, download=True, transform=torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize( (0.1307,), (0.3081,)) ])) #准备数据迭代器 train_dataloader = torch.utils.data.DataLoader(dataset,batch_size=64,shuffle=True) 准备测试集 import torchvision #准备数据集，其中0.1307，0.3081为MNIST数据的均值和标准差，这样操作能够对其进行标准化 #因为MNIST只有一个通道（黑白图片）,所以元组中只有一个值 dataset = torchvision.datasets.MNIST('/data', train=False, download=True, transform=torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize( (0.1307,), (0.3081,)) ])) #准备数据迭代器 train_dataloader = torch.utils.data.DataLoader(dataset,batch_size=64,shuffle=True) 3. 构建模型补充：全连接层：当前一层的神经元和前一层的神经元相互链接，其核心操作就是$y = wx​$，即矩阵的乘法，实现对前一层的数据的变换 模型的构建使用了一个三层的神经网络，其中包括两个全连接层和一个输出层，第一个全连接层会经过激活函数的处理，将处理后的结果交给下一个全连接层，进行变换后输出结果 那么在这个模型中有两个地方需要注意： 激活函数如何使用 每一层数据的形状 模型的损失函数 3.1 激活函数的使用前面介绍了激活函数的作用，常用的激活函数为Relu激活函数，他的使用非常简单 Relu激活函数由import torch.nn.functional as F提供，F.relu(x)即可对x进行处理 例如： In [30]: b Out[30]: tensor([-2, -1, 0, 1, 2]) In [31]: import torch.nn.functional as F In [32]: F.relu(b) Out[32]: tensor([0, 0, 0, 1, 2]) 3.2 模型中数据的形状（【添加形状变化图形】） 原始输入数据为的形状:[batch_size,1,28,28] 进行形状的修改：[batch_size,28*28] ,(全连接层是在进行矩阵的乘法操作) 第一个全连接层的输出形状：[batch_size,28]，这里的28是个人设定的，你也可以设置为别的 激活函数不会修改数据的形状 第二个全连接层的输出形状：[batch_size,10],因为手写数字有10个类别 构建模型的代码如下： import torch from torch import nn import torch.nn.functional as F class MnistNet(nn.Module): def __init__(self): super(MnistNet,self).__init__() self.fc1 = nn.Linear(28*28*1,28) #定义Linear的输入和输出的形状 self.fc2 = nn.Linear(28,10) #定义Linear的输入和输出的形状 def forward(self,x): x = x.view(-1,28*28*1) #对数据形状变形，-1表示该位置根据后面的形状自动调整 x = self.fc1(x) #[batch_size,28] x = F.relu(x) #[batch_size,28] x = self.fc2(x) #[batch_size,10] 可以发现：pytorch在构建模型的时候形状上并不会考虑batch_size 3.3 模型的损失函数首先，我们需要明确，当前我们手写字体识别的问题是一个多分类的问题，所谓多分类对比的是之前学习的2分类 回顾之前的课程，我们在逻辑回归中，我们使用sigmoid进行计算对数似然损失，来定义我们的2分类的损失。 在2分类中我们有正类和负类，正类的概率为$P(x) = \\frac{1}{1+e^{-x}} = \\frac{e^x}{1+e^x}$,那么负类的概率为$1-P(x)​$ 将这个结果进行计算对数似然损失$-\\sum y log(P(x))​$就可以得到最终的损失 那么在多分类的过程中我们应该怎么做呢？ 多分类和2分类中唯一的区别是我们不能够再使用sigmoid函数来计算当前样本属于某个类别的概率，而应该使用softmax函数。 softmax和sigmoid的区别在于我们需要去计算样本属于每个类别的概率，需要计算多次，而sigmoid只需要计算一次 softmax的公式如下：$$\\sigma(z)_j = \\frac{e^{z_j}}{\\sum^K_{k=1}e^{z_K}} ,j=1 \\cdots k$$ 例如下图： 假如softmax之前的输出结果是2.3, 4.1, 5.6,那么经过softmax之后的结果是多少呢？$$Y1 = \\frac{e^{2.3}}{e^{2.3}+e^{4.1}+e^{5.6}} \\Y2 = \\frac{e^{4.1}}{e^{2.3}+e^{4.1}+e^{5.6}} \\Y3 = \\frac{e^{5.6}}{e^{2.3}+e^{4.1}+e^{5.6}} \\$$ 对于这个softmax输出的结果，是在[0,1]区间，我们可以把它当做概率 和前面2分类的损失一样，多分类的损失只需要再把这个结果进行对数似然损失的计算即可 即：$$\\begin{align*}&amp; J = -\\sum Y log(P) &amp;, 其中 P = \\frac{e^{z_j}}{\\sum^K_{k=1}e^{z_K}} ,Y表示真实值\\end{align*}$$最后，会计算每个样本的损失，即上式的平均值 我们把softmax概率传入对数似然损失得到的损失函数称为交叉熵损失 在pytorch中有两种方法实现交叉熵损失 criterion = nn.CrossEntropyLoss() loss = criterion(input,target) 2. ``` #1. 对输出值计算softmax和取对数 output = F.log_softmax(x,dim=-1) #2. 使用torch中带权损失 loss = F.nll_loss(output,target) 带权损失定义为：$l_n = -\\sum w_{i} x_{i}$，其实就是把$log(P)$作为$x_i$,把真实值Y作为权重 4. 模型的训练训练的流程： 实例化模型，设置模型为训练模式 实例化优化器类，实例化损失函数 获取，遍历dataloader 梯度置为0 进行向前计算 计算损失 反向传播 更新参数 mnist_net = MnistNet() optimizer = optim.Adam(mnist_net.parameters(),lr= 0.001) def train(epoch): mode = True mnist_net.train(mode=mode) #模型设置为训练模型 train_dataloader = get_dataloader(train=mode) #获取训练数据集 for idx,(data,target) in enumerate(train_dataloader): optimizer.zero_grad() #梯度置为0 output = mnist_net(data) #进行向前计算 loss = F.nll_loss(output,target) #带权损失 loss.backward() #进行反向传播，计算梯度 optimizer.step() #参数更新 if idx % 10 == 0: print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format( epoch, idx * len(data), len(train_dataloader.dataset), 100. * idx / len(train_dataloader), loss.item())) 5. 模型的保存和加载5.1 模型的保存torch.save(mnist_net.state_dict(),\"model/mnist_net.pt\") #保存模型参数 torch.save(optimizer.state_dict(), 'results/mnist_optimizer.pt') #保存优化器参数 5.2 模型的加载mnist_net.load_state_dict(torch.load(\"model/mnist_net.pt\")) optimizer.load_state_dict(torch.load(\"results/mnist_optimizer.pt\")) 6. 模型的评估评估的过程和训练的过程相似，但是： 不需要计算梯度 需要收集损失和准确率，用来计算平均损失和平均准确率 损失的计算和训练时候损失的计算方法相同 准确率的计算： 模型的输出为[batch_size,10]的形状 其中最大值的位置就是其预测的目标值（预测值进行过sotfmax后为概率，sotfmax中分母都是相同的，分子越大，概率越大） 最大值的位置获取的方法可以使用torch.max,返回最大值和最大值的位置 返回最大值的位置后，和真实值（[batch_size]）进行对比，相同表示预测成功 def test(): test_loss = 0 correct = 0 mnist_net.eval() #设置模型为评估模式 test_dataloader = get_dataloader(train=False) #获取评估数据集 with torch.no_grad(): #不计算其梯度 for data, target in test_dataloader: output = mnist_net(data) test_loss += F.nll_loss(output, target, reduction='sum').item() pred = output.data.max(1, keepdim=True)[1] #获取最大值的位置,[batch_size,1] correct += pred.eq(target.data.view_as(pred)).sum() #预测准备样本数累加 test_loss /= len(test_dataloader.dataset) #计算平均损失 print('\\nTest set: Avg. loss: {:.4f}, Accuracy: {}/{} ({:.2f}%)\\n'.format( test_loss, correct, len(test_dataloader.dataset), 100. * correct / len(test_dataloader.dataset))) 7. 完整的代码如下：import torch from torch import nn from torch import optim import torch.nn.functional as F import torchvision train_batch_size = 64 test_batch_size = 1000 img_size = 28 def get_dataloader(train=True): assert isinstance(train,bool),\"train 必须是bool类型\" #准备数据集，其中0.1307，0.3081为MNIST数据的均值和标准差，这样操作能够对其进行标准化 #因为MNIST只有一个通道（黑白图片）,所以元组中只有一个值 dataset = torchvision.datasets.MNIST('/data', train=train, download=True, transform=torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize((0.1307,), (0.3081,)),])) #准备数据迭代器 batch_size = train_batch_size if train else test_batch_size dataloader = torch.utils.data.DataLoader(dataset,batch_size=batch_size,shuffle=True) return dataloader class MnistNet(nn.Module): def __init__(self): super(MnistNet,self).__init__() self.fc1 = nn.Linear(28*28*1,28) self.fc2 = nn.Linear(28,10) def forward(self,x): x = x.view(-1,28*28*1) x = self.fc1(x) #[batch_size,28] x = F.relu(x) #[batch_size,28] x = self.fc2(x) #[batch_size,10] # return x return F.log_softmax(x,dim=-1) mnist_net = MnistNet() optimizer = optim.Adam(mnist_net.parameters(),lr= 0.001) # criterion = nn.NLLLoss() # criterion = nn.CrossEntropyLoss() train_loss_list = [] train_count_list = [] def train(epoch): mode = True mnist_net.train(mode=mode) train_dataloader = get_dataloader(train=mode) print(len(train_dataloader.dataset)) print(len(train_dataloader)) for idx,(data,target) in enumerate(train_dataloader): optimizer.zero_grad() output = mnist_net(data) loss = F.nll_loss(output,target) #对数似然损失 loss.backward() optimizer.step() if idx % 10 == 0: print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format( epoch, idx * len(data), len(train_dataloader.dataset), 100. * idx / len(train_dataloader), loss.item())) train_loss_list.append(loss.item()) train_count_list.append(idx*train_batch_size+(epoch-1)*len(train_dataloader)) torch.save(mnist_net.state_dict(),\"model/mnist_net.pkl\") torch.save(optimizer.state_dict(), 'results/mnist_optimizer.pkl') def test(): test_loss = 0 correct = 0 mnist_net.eval() test_dataloader = get_dataloader(train=False) with torch.no_grad(): for data, target in test_dataloader: output = mnist_net(data) test_loss += F.nll_loss(output, target, reduction='sum').item() pred = output.data.max(1, keepdim=True)[1] #获取最大值的位置,[batch_size,1] correct += pred.eq(target.data.view_as(pred)).sum() test_loss /= len(test_dataloader.dataset) print('\\nTest set: Avg. loss: {:.4f}, Accuracy: {}/{} ({:.2f}%)\\n'.format( test_loss, correct, len(test_dataloader.dataset), 100. * correct / len(test_dataloader.dataset))) if __name__ == '__main__': test() for i in range(5): #模型训练5轮 train(i) test()","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://inactionzz.github.io/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"nlp","slug":"nlp","permalink":"http://inactionzz.github.io/tags/nlp/"}],"author":"ZZ"},{"title":"springboot","slug":"springboot","date":"2022-01-09T16:21:37.000Z","updated":"2022-01-17T16:54:31.146Z","comments":true,"path":"posts/4b3516a4.html","link":"","permalink":"http://inactionzz.github.io/posts/4b3516a4.html","excerpt":"","text":"运维实用篇打包和运行 对SpringBoot项目打包（执行Maven构建指令package）mvn package 运行项目（执行启动指令)java –jar springboot.jar 配置高级 创建临时属性 带属性数启动SpringBootjava –jar springboot.jar –-server.port=80 携带多个属性启动SpringBoot，属性间使用空格分隔: 属性加载优先顺序:参看 https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config 临时属性设置（开发环境) 带属性启动SpringBoot程序，为程序添加运行属性,在idea configuration中进行配置。 通过编程形式带参数启动SpringBoot程序，为程序添加运行参数 public static void main(String[] args) { String[] arg = new String[1]; arg[0] = \"--server.port=8080\"; SpringApplication.run(SSMPApplication.class, arg); } 配置文件分类 1级： file ：config/application.yml 【最高】 2级： file ：application.yml 3级：classpath：config/application.yml 4级：classpath：application.yml 作用： 1级与2级留做系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控 3级与4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控 自定义配置文件 通过启动参数加载配置文件（无需书写配置文件扩展名) 通过启动参数加载指定文件路径下的配置文件 通过启动参数加载指定文件路径下的配置文件时可以加载多个配置。 多环境开发多环境多环境配置例子:多环境开发需要设置若干种常用环境，例如开发、生产、测试环境 #应用环境 #公共配制 spring: profiles: active: dev #设置环境 #开发环境 --- spring: config: activate: on-profile: dev server: port: 81 #生产环境 --- spring: profiles: pro server: port: 80 #测试环境 --- spring: profiles: test server: port: 82 多环境开发（YAML版）多配置文件格式 主启动配置文件application.yml(在主配置文件中使用test)#应用环境 #公共配制 spring: profiles: active: test 主启动配置文件application.yml2. 环境分类配置文件application-pro.yml ```java server: port: 81 环境分类配置文件application-dev.yml server: port: 82 环境分类配置文件application-test.ymlserver: port: 83 多环境开发多文件版（properties版）类似yml版 多环境开发独立配置文件书写技巧 根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下： application-devDB.yml application-devRedis.yml application-devMVC.yml 使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔spring: profiles: active: dev include: devDB,devMVC 注意事项:当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效 从Spring2.4版开始使用group属性替代include属性，降低了配置书写量使用group属性定义多种主环境与子环境的包含关系 spring: profiles: active: dev group: \"dev\": devDB,devMVC \"pro\": proDB,proMVC \"test\": testDB,testRedis,testMVC 注意事项：使用group属性，会覆盖 主环境dev (active) 的内容，最后加载的环境属性生效The following profiles are active: dev,devDB,devMVC 日志日志基础操作日志的作用 编程期调试代码 运营期记录信息 记录日常运营的重要信息（峰值流量，平均响应时长……） 记录应用的报错信息（错误堆栈） 记录运维过程数据（扩容，宕机、报警……） 代码中使用日志工具记录日志 先引入 Lombok 工具类&lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 1.添加日志记录操作@RestController @RequestMapping(\"/books\") public class BookController { private static final Logger log = LoggerFactory.getLogger(BookController.class); @GetMapping public String getById() { System.out.println(\"springboot is running...\"); log.debug(\"debug ...\"); log.info(\"info ...\"); log.warn(\"warn ...\"); log.error(\"error ...\"); return \"springboot is running...\"; } } 日志级别TRACE：运行堆栈信息，使用率低DEBUG：程序员调试代码使用INFO：记录运维过程数据WARN：记录运维过程报警数据ERROR：记录错误堆栈信息FATAL：灾难信息，合并计入ERROR 2.设置日志输出级别# 开启 debug 模式，输出调试信息，常用于检查系统运行状况 debug: true # 设置日志级别， root 表示根节点，即整体应用日志级别 logging: level: root: debug 3.设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别logging: # 设置分组 group: # 自定义组名，设置当前组中所包含的包 ebank: com.example.controller,com.example.service,com.example.dao iservice: com.alibaba level: root: info # 设置某个包的日志级别 # com.example.controller: debug # 为对应组设置日志级别 ebank: warn 开发实用篇","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://inactionzz.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://inactionzz.github.io/tags/JAVA/"}],"author":"ZZ"},{"title":"hexo博客搭建","slug":"new-blog","date":"2021-05-27T03:41:03.000Z","updated":"2021-06-01T09:21:14.781Z","comments":true,"path":"posts/7639fcc6.html","link":"","permalink":"http://inactionzz.github.io/posts/7639fcc6.html","excerpt":"","text":"0x001 简单介绍 基于Hexo框架，采用hexo-theme-matery主题 0x002 Hexo 初级搭建 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git的作用是将本地的网页文件传到github上。 Git下载地址 Git教程 windows： 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择Use Git from the Windows Command Prompt。 2. 安装node.jsHexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。 windows： 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 3. 添加npm国内源使用阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4. 安装Hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 比如我的博客文件都存放在E:\\MyBlog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v验证是否安装成功。 到此为止hexo就安装完了。 接下来初始化一下hexo,即初始化我们的网站，输入hexo init初始化文件夹 hexo init MyBlog 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 到此为止，本地的网站配置完成了。 输入hexo g生成静态网页，然后输入hexo s打开本地服务器 hexo g hexo s 5. 注册Github账号创建个人仓库接下来就去注册一个github账号，用来存放我们的网站。 打开https://github.com/，新建一个项目仓库New repository，如下所示： 然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上 要创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。例如我的：http://LuckyZmj.github.io 6. 生成SSH添加到GitHub生成SSH添加到GitHub，连接Github与本地。右键打开git bash here，然后输入下面命令： git config --global user.name \"注册GitHub用户名\" git config --global user.email \"注册GitHub的邮箱\" 用以下两条，检查一下你有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C \"注册GitHub的邮箱\" 这个时候它会告诉你已经生成了.ssh的文件夹。在git bash中输入 cat ~/.ssh/id_rsa.pub 将输出的内容复制到框中，点击确定保存。 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。如图： 在git bash输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 ssh -T git@github.com 7. 将hexo部署到GitHub将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。找到如下配置进行修改： deploy: type: git repository: https://github.com/LuckyZmj/LuckyZmj.github.io branch: master repository修改为你自己的github项目地址即可，就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save 然后就可以部署提交到github，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西。 hexo generate，生成静态文章，可以用 hexo g缩写 ，hexo deploy部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 8. 写文章和发布文章首先在博客根目录下右键打开git bash here，安装一个扩展npm i hexo-deployer-git。 npm i hexo-deployer-git 然后输入hexo new post \"article title\"，新建一篇文章。 hexo new post \"article title\" 然后打开E:\\MyBlog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件。 另外推荐直接使用有道云编写markdown文章，不仅可以实时预览，还可以快捷的生成markdown语法格式，具体效果如下图所示。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章了。 到此为止，Hexo初级搭建就已经完成了。 0x003 Hexo 优化定制 1. Hexo相关目录文件1.1 博客目录构成介绍node_modules是node.js各种库的目录，public是生成的网页文件目录，scaffolds里面就三个文件，存储着新文章和新页面的初始设置，source是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，themes存放着主题文件，一般也用不到。 我们平时写文章只需要关注source/_posts这个文件夹就行了。 - node_modules - public - scaffolds - source - _data - _posts - about - archives - categories - friends - tags - themes 1.2 hexo基本配置在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 1.2.1 网站参数描述title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言timezone网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 1.2.2 网址参数描述url网址root网站根目录 permalink文章的永久链接格式permalink_defaults永久链接中各部分的默认值 在这里，你需要把url改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。 参数结果 :year/:month/:day/:title /2019/08/10/hello-world :year-:month-:day-:title.html 2019-08-10-hello-world.html :category/:titlefoo /bar/hello-world 2. 定制主题这里推荐作者洪卫的hexo-blog-fly博客主题，该主题是基于hexo-theme-matery优化的，需要把博客相关信息换成您自己的就可以部署了，极大简化了构建博客的工作量和复杂度。 2.1 简单使用方法 安装Git, 安装nodeJS，安装Hexo 你可以直接fork一份源码到你的仓库，clone到本地博客文件夹内 在本地博客仓库运行npm i命令安装依赖包 直接修改配置信息，改成自己的信息 运行命令hexo clean（清除生成文件），hexo g（生成网页）， hexo s（本地预览），hexo d（部署） 2.2 原主题特性: 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 2.3 新增加特性: 修改了原主题的一些很多bug 加入图片懒加载功能，在根目录配置文件开启和关闭 增加留言板功能 在关于板块,加入简历功能页 增加视听[视觉听觉影音]板块 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。 增加网站运行时间显示 增加动漫模型 整体替换Banner图片和文章特色图片 增加分类相册功能 修改了一些控件的参数 修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观 解决首页文章列表卡片上方 border-radius圆角失效的bug 添加页面樱花飘落动效 添加鼠标点击烟花爆炸动效 加入天气接口控件 加入鼠标点击文字特效 添加页面雪花飘落动效 添加在线聊天插件 调整线聊天插件参数，使之能够随着鼠标滑动位置自适应调整 持续更新… 2.4 切换主题如果想自己动手对hexo-theme-matery优化的话，可以修改Hexo根目录下的 _config.yml的 theme 的值 theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 2.5 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： --- title: categories date: 2018-09-30 17:25:30 type: \"categories\" layout: \"categories\" --- 2.6 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： --- title: tags date: 2018-09-30 18:23:38 type: \"tags\" layout: \"tags\" --- 2.7 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： --- title: about date: 2018-09-30 17:25:30 type: \"about\" layout: \"about\" --- 2.8 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，前提是已经开启了第三方评论系统才能显示。如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： --- title: contact date: 2018-09-30 17:25:30 type: \"contact\" layout: \"contact\" --- 2.9 新建友情链接 friends 页（可选的）friends 页是用来展示友情链接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： --- title: friends date: 2018-12-12 21:25:30 type: \"friends\" layout: \"friends\" --- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： [{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\" }] 2.10 一级菜单导航配置配置基本菜单导航的名称、路径url和图标icon 菜单导航名称可以是中文也可以是英文(如：Index或主页) 图标icon 可以在Font Awesome 中查找 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 2.11 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children) 在children下创建二级菜单的 名称name,路径url和图标icon. 注意每个二级菜单模块前要加 -. 注意缩进格式 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件。 2.12 代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： highlight: enable: false prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 更多代码块优化详细内容请访问：http://luckyzmj.cn/posts/1b9a9e28.html 2.13 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： search: path: search.xml field: post 2.14 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount 插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 2.15 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 2.16 添加 RSS 订阅支持（可选的）本主题中还使用到了hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 2.17 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 2.18 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 2.19 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 2.20 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 2.21 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 2.22 配置音乐播放器（可选的）要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可 # 是否在首页显示音乐 music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 server: netease #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 503838841 #require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 提示： server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。 type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id获取示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，地址栏有一串数字，playlist的id即为这串数字。 2.23文章 Front-matter 介绍Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。最简示例 --- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 --- 最全示例 --- title: theme主题介绍 date: 2018-09-07 09:25:00 author: 赵奇 img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- 2.24 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：修改主题颜色 在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： /* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */ .bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); } @-webkit-keyframes rainbow { /* 动态切换背景颜色. */ } @keyframes rainbow { /* 动态切换背景颜色. */ } body { /* background-color: #eaeaea; */ /* 增加背景壁纸*/ background: url(\"https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png\"), url(\"http://luckyzmj.cn/img/yun.jpg\") 0px 0px; background-attachment: fixed; margin: 0; color: #34495e; } 2.25 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 2.26 优化目录栏在 themes\\Matery\\layout\\_partial\\post-detail-toc.ejs，修改内容如下： .toc-widget { padding-left: 20px; width: 345px; background-color: rgb(255, 255, 255,0.7); border-radius: 10px; box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important; } #toc-content { margin-bottom: 20px; } 0x004 更多详细教程以下几篇文章都是基于Hexo框架和hexo-theme-matery主题优化的教程，大家如果遇到问题，可以参考其中的方法。 Hexo+Github博客搭建完全教程 hexo-theme-matery作者教程 Hexo+github搭建博客(超级详细版，精细入微) hexo（matery）背景、滚动条优化+增加点击跳评论0x005 转载声明原文章：http://luckyzmj.cn/posts/e3e08109.html","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://inactionzz.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://inactionzz.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"http://inactionzz.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://inactionzz.github.io/tags/Github/"}],"author":"ZZ"},{"title":"篮球公园","slug":"Basketball","date":"2021-05-10T09:01:59.000Z","updated":"2021-10-25T12:00:17.086Z","comments":true,"path":"posts/8639fcc9.html","link":"","permalink":"http://inactionzz.github.io/posts/8639fcc9.html","excerpt":"","text":"gif区 图片区","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://inactionzz.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://inactionzz.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"ZZ"},{"title":"Machine learning","slug":"Machine-learning  and Deep learning","date":"2020-10-07T03:00:00.000Z","updated":"2021-12-19T04:21:44.487Z","comments":true,"path":"posts/4b3510a4.html","link":"","permalink":"http://inactionzz.github.io/posts/4b3510a4.html","excerpt":"","text":"“西瓜书”第十一章（特征选择与稀疏学习）1.子集搜索和评价特征选择和降维计算一样，都能有效的减轻维数灾难问题，事实上，特征选择和降维计算是处理高维数据的两大主流技术。但与降维将高维属性投影嵌入到低维空间不同，特征选择是直接将无关的属性去除，这会有效降低学习任务的难度 子集搜索: 可以以一个属性开始进行“前向”搜索，首先，找到性能最好的单个属性，然后在该属性基础上在剩下的属性中进行寻找，找到下一个属性使得两个属性的集合性能最好，以此类推直到没有属性可以添加进入属性子集中使得性能更优时停止。 相对应的，我们也可以以全量属性进行“后向”搜索，每次尝试去掉一个无关属性。 子集评价： 可以使用“信息增益”（详情请查看第四章决策树）来评估，其本质是比较特征子集 A 对数据集的划分与实际标记信息 Y 对数据集的划分的差别，其它能判断两个划分差异的机制都能用于特征子集评价 常见的特征选择方法大致可分为三类：过滤式（filter）、包裹式（wrapper）和嵌入式（embedding）详见：https://www.jianshu.com/p/d82b5d3048d2 1.稀疏表示与字典学习数据集可以以矩阵表示，每一行为一个样本，每一列为一个属性。特征选择所考虑的问题是特征具有“稀疏性”，即矩阵中的许多列与当前学习任务无关，我们需要通过特征选择去除这些列。 稀疏表示： 在数据集 D 所对应的矩阵中存在很多零元素，但这些零元素并不是以整列、整行形式存在的。当样本具有稀疏表示时，对学习任务有不少好处，比如稀疏表示的数据更容易线性可分。同时，稀疏表示的数据在存储上的负担不大。 字典学习： 我们可以通过将数据转换为“恰当稀疏”的形式，获得稀疏表示的好处，简化学习任务。这种为普通稠密表达的样本找到合适的字典，将样本转化为稀疏表示形式，从而使学习任务得以简化，模型复杂度得以降低，通常称为“字典学习”（dictionary learning），亦称“稀疏编码”（sparse coding）。 6.压缩感知（compressed sensing）在现实任务中，我们常希望能根据部分信息来恢复全部信息。会拥有这种需求的原因是因为，在实践中为了便于数据的传输、存储，人们通常会将数据进行压缩，这有可能会损失一部分信息，而传输的过程中又可能会丢失一部分信息。这时候拥有根据接收到的受损的数据来恢复全部数据的能力就很重要了，而压缩感知为解决此类问题提供了新思路。压缩感知的核心思想是：一般来说丢失了部分信息的数据是无法恢复为原始数据的，但是如果将原始数据通过字典学习表示成稀疏表示时，却可以比较好的进行复原。这是因为稀疏性使得未知因素的影响大大的减少。与特征选择、稀疏表示不同，压缩感知关注的是如何利用信号本身的稀疏性，从部分观测样本中恢复原信号。通常认为，压缩感知分为“感知测量”和“重构恢复”这两个阶段。 “感知测量”关注如何对原始信号进行处理以获得其稀疏表示，这方面涉及我们前边提的特征选择、稀疏表示等内容 “重构恢复”关注的是如何从少量观测中恢复原信号，这才是压缩感知的精髓，当我们谈到压缩感知时，通常是指这部分。 命名实体识别Bert+CRF参考：https://www.cnblogs.com/anai/p/11691191.html 知识图谱与论辩挖掘1.Employing Argumentation Knowledge Graphs for Neural Argument Generation2.Argument Pair Extraction via Attention-guided Multi-Layer Multi-Cross Encoding3.Trigger is Not Sufficient: Exploiting Frame-aware Knowledge for Implicit Event Argument Extraction4.Towards Argument Mining for Social Good: A Survey5.Syntopical Graphs for Computational Argumentation Tasks6.ConvoSumm: Conversation Summarization Benchmark and Improved Abstractive Summarization with Argument Mining7.Exploring Discourse Structures for Argument Impact Classification TransformerTransformer的特点是有多少个输入就有多少个输出 构建完整的论辩结构需要考虑论辩型式、领域知识、假定作者和潜在读者的共同认知、以及论辩发生的背景 论文汇报： 大家好，今天我要讲的是一篇2020年发表在AAAI会议上的论文，K-BERT:Enabling Language Representation with Knowledge Graph.这篇文章将知识图谱（KG）应用在BERT预训练模型中创建了K-BERT模型，目的就是用以解决BERT模型在专业领域表现不佳的问题。 BERT是一个基于Transformer和大规模开放语料的双向预训练语言模型,在预训练阶段训练 Masked LM和Next Sentence Prediction两个任务，然后在下游任务中进行微调就可以吸收专业领域知识，但是由于预训练和微调之间存在领域知识差异，因而在领域知识驱动型任务上，BERT无法取得满意的表现。 如果要在领域知识驱动型的任务上取得更好的表现，一种方法是利用大量具有领域知识的语料库预先训练一个强调特定领域的模型，而不是使用公开提供的模型。 但是，预训练既耗时且计算量大，并且其解释性和可控性都难以把握。另一种方法就是本文所采用的方法：引入知识图谱来使得模型成为领域专家，因为： 1.很多领域的知识图谱都是结构化数据； 2.在减小预训练成本的同时还能将领域知识植入模型； 3.模型有更好的可解释性，因为植入的知识是可手工编辑的。 但是，如何将外部知识整合到模型中成了一个关键点，这一步通常存在两个难点： 1.异构嵌入空间（Heterogeneous Embedding Space）：&nbsp;即文本的单词embedding和知识库的实体embedding通常是通过不同方式获取的，使得向量空间不一致； 2.知识噪声（Knowledge Noise）：&nbsp;即过多的知识融合可能会使原始句子偏离正确的本意。 这也这篇论文提出的模型K-bert所解决的两个问题。 K-BERT模型主要包括四个部分，分别是知识层，嵌入层，可见层和Mask-Transformer编码 知识层用于将知识图谱注入到句子中并且完成句子树的转换，给定知识图谱K，输入一句话s={w0,w1,w2,…,wn}，经KL层后输出句子树t={w0,w1,…,wi {(ri0, wi0),….(rik,wik)},…,wn}。输出的句子树包含知识图谱中实体的三元组关系。 这一过程可以被分为两个具体步骤：知识查询（K-Query）和知识注入（K-Inject）： 1.知识查询：利用输入句子中所有的实体去查询知识图谱中相关的三元组 2.知识注入：把相关三元组注入到句子中形成右图这样的句子树。 接着是嵌入层，和 BERT 类似，输入的句子需要经过embedding，作为模型的输入。具体 embedding 由三个部分组成，分别是 token embedding，soft position embedding 以及 segment embedding。传统的 BERT 模型，只能处理序列结构的句子输入，而前面的知识层得到的是图结构的句子树，无法直接输入到 BERT 模型中。如果强行把句子树平铺成序列输入模型，必然造成结构信息的丢失。如果使用BERT的 position embedding 方式，即 hard-position index，那么 position index 就和灰色的标示一样，我们的得到的句子是： CLS Tim(1) Cook(2) CEO(3) Apple(4) is(5) visiting(6) Beijing(7) capital(8) of(9) China(10) is_a(11) City(12) now(13) 这就导致了我们原本的句子的顺序发生了变化，失去了句子主干的位置信息。例如我们的例子中，CEO Apple 被插入到 is 之间，但是其实 is 的主语是 Tim Cook, 而不是 Apple，因此我们为了保持句子主干的位置信息，这边需要将 is 的位置 index 设置为 3 而不是5。这就是采用的soft-position index，就如上图中的红色 index 标示。 但是这就又引起了一个问题，就是在上述例子中，token CEO 和 is 的位置表示一样，这就意味着在计算 self-attention 的时候，它们的位置是很接近的，可能出现的attention score会很大，可是实际上，他们并没有任何关联。同理 Apple 和 visiting 的位置index 都是4，但是其实他们并没有任何联系，而在计算 self-attention 的时候，他们会 attend 到彼此，并且根据之前论文的结论，一般字都会给其周围的字很大的attention score。所有为了解决这个问题，我们引入了seeing layer，控制了 self-attention 的可见域。 图 2 中的句子树对应的可见矩阵如上图所示，其中一共有 13 个 token，所以是一个 13*13 的矩阵，红色表示对应位置的两个 token 相互可见，白色表示相互不可见。对于一个可见矩阵 M，相互可见的红色点取值为 0，相互不可见的白色取值为负无穷。 WikiZh 指中文维基百科语料库，用于训练中文BERTWebtextZh 是大规模，高质量的中文问答（Q＆A）语料库知识图谱：CN-DBpedia （Xu et al. 2017）是复旦大学知识工作实验室开发的大型开放域百科全书，涵盖数千万个实体和数亿个关系HowNet 是针对中文词汇和概念的大型语言知识库MedicalKG 是我们自行开发的中医概念KG Google BERT 该模型已在WikiZh上进行了预训练，并由Google发布（Devlin et al. 2018）。我们的BERT 通过WikiZh和WebtextZh的预训练对BERT的重新实现。 本文首先比较KBERT和BERT在8个中文开放域NLP任务上的性能在这八项任务中，书评，Chnsenticorp，购物和微博属于单句分类任务。 模型框架使用 对于一个问题，我们首先想的是解决问题的办法，也就是模型构建部分model.py。当模型确定了，那我们就要构建数据迭代器（utils.py）给模型喂数据了，而utils.py读入的数据是preprocess.py清洗干净的数据。 当构建以上这几部分之后，便是模型训练部分train_fine_tune.py，这个部分包含训练、验证F1和保存每一个epoch训练模型的过程。一开始我们训练单模得先确定单模是否有效，我们可以通过train_fine_tune.py的main函数将训练集和验证集都用验证集去表示，看一下验证集F1是否接近90%，若接近则说明我们的模型构建部分没有出错，但不保证我们的F1评估公式是否写错。因此，我们使用刚刚用验证集训练得到的模型，通过predict.py来预测验证集，人工检验预测的结果是否有效，这样子就能保证我们整体的单模流程完全没问题了。 其中，utils.py也有main函数，可以用来检验我们构造的Batch数据是否有误，直接打印出来人工检验一下即可。整个框架的超参数都在config.py处设置，加强框架的解耦性，避免了一处修改，处处修改的情况。 最后就是后处理规则postprocess和融合ensemble两部分，这里的主观性比较强，一般都是根据具体问题具体分析来操作。 整体的框架也可复用到其他问题上，只需要根据我们修改的model.py来确定喂入的Batch数据格式，其他的代码文件也只是根据问题去修改相应部分，降低了调试成本。","categories":[{"name":"算法篇","slug":"算法篇","permalink":"http://inactionzz.github.io/categories/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"Machine learning -","slug":"Machine-learning","permalink":"http://inactionzz.github.io/tags/Machine-learning/"}],"author":"ZZ"},{"title":"Python","slug":"Python","date":"2020-05-24T03:00:00.000Z","updated":"2021-06-01T06:14:45.096Z","comments":true,"path":"posts/3b3510a4.html","link":"","permalink":"http://inactionzz.github.io/posts/3b3510a4.html","excerpt":"","text":"前言Py学习笔记","categories":[{"name":"语言篇","slug":"语言篇","permalink":"http://inactionzz.github.io/categories/%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://inactionzz.github.io/tags/Python/"}],"author":"ZZ"},{"title":"JAVA","slug":"JAVA","date":"2020-05-24T02:00:00.000Z","updated":"2021-07-10T14:21:03.955Z","comments":true,"path":"posts/4b3510a4.html","link":"","permalink":"http://inactionzz.github.io/posts/4b3510a4.html","excerpt":"","text":"前言JAVA学习笔记 JVM，JRE，JDK JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 JRE(Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库。 JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 tip:三者关系： JDK &gt; JRE &gt; JVM IDEA常用快捷键 快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标位置下面 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释 Alt+Ins 自动生成代码，toString，get，set等方法 Alt+Shift+上下箭头 移动当前代码行 数组 定义方式一：数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度]; 定义方式二：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3…}; 定义方式三：数据类型[] 数组名 = {元素1,元素2,元素3…}; 面向对象概述Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。 类和对象1.类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。现实中，描述一类事物可用：属性：就是该事物的状态信息。行为：就是该事物能够做什么。2.对象：对象：是一类事物的具体体现。对象是类的一个实例 ，必然具备该类事物的属性和行为。3.类和对象的关系： 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 4.类的定义： public class ClassName { //成员变量 //成员方法 } 定义类：就是定义类的成员，包括成员变量和成员方法。成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。成员方法：和以前定义方法几乎是一样的。只不过把static去掉.5.对象的使用创建对象： 类名 对象名 = new 类名(); 使用对象访问类中的成员： 对象名.成员变量； 对象名.成员方法()； 6.成员变量和局部变量的不同 在类中的位置不同 1.成员变量：类中，方法外2.局部变量：方法中或者方法声明上(形式参数) 作用范围不一样 1.成员变量：类中2.局部变量：方法中 初始化值的不同 1.成员变量：有默认值2.局部变量：没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 1.成员变量：堆内存2.局部变量：栈内存 生命周期不同 1.成员变量：随着对象的创建而存在，随着对象的消失而消失2.局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 封装概述面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。封装的原则：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 封装的操作private关键字： private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只在本类中才能访问。 具体的操作： 1.修改属性的可见性来限制对属性的访问（一般限制为private），例如： public class Person { private String name; private int age; } 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 2.对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： public class Person{ private String name; private int age; ​ public int getAge(){ return age; } ​ public String getName(){ return name; } ​ public void setAge(int age){ this.age = age; } ​ public void setName(String name){ this.name = name; } } 封装的优化1. this 关键字：采用this关键字是为了解决局部成员变量和方法的形参变量的重名冲突。使用格式： this.成员变量名； 2. 构造方法：当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。tip：无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。使用格式： 修饰符 构造方法名(参数列表){ // 方法体 } 构造方法名需要与其所在的类名相同实例： public class Student { private String name; private int age; // 无参数构造方法 public Student() {} // 有参数构造方法 public Student(String name,int age) { this.name = name; this.age = age; } } 构造方法可以定义参数也可以不定义。 3.标准代码–JavaBean：JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。 规范的类： public class ClassName{ //成员变量 //无参构造方法【必须】 //有参构造方法【建议】 //成员方法 //getXxx() //setXxx() } Scanner类一个可以解析基本类型和字符串的简单文本扫描器 创建Scanner对象 Scanner s = new Scanner(System.in); 使用next方法接收字符串： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 // next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if (scan.hasNext()) { String str1 = scan.next(); System.out.println(\"输入的数据为：\" + str1); } scan.close(); } } 其中hasNext方法用来判断是否还有输入的数据：用nextline方法接收字符串： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 // nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if (scan.hasNextLine()) { String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\" + str2); } scan.close(); } } tip：next与nextline的区别：next(): 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。next() 不能得到带有空格的字串。 nextLine()： 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 补充：可以用nextxxx获得整形，浮点型等数据类型hasnextxxx用来判断数据类型。 ArrayList类ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。ArrayList 继承了 AbstractList ，并实现了 List 接口格式： ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;(); // 初始化 添加元素的方法：add objectName.add(\"\"); 访问元素的方法： get objectName.get(\"\"); 修改元素的方法： set objectName.set(2, \"Wiki\"); // 第一个参数为索引位置，第二个为要修改的值 修改元素的方法： remove objectName.remove(3); // 删除第四个元素 计算大小： size objectName.size(); 注意：ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下： 基本类型 基本类型包装类 byte Byte short Short int Integer long Long loat Float double Double char Character boolean Boolean String 类字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。 几个常用的方法获取功能的方法： public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。 public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。 转换功能的方法： public char[] toCharArray () ：将此字符串转换为新的字符数组。 public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。 public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。 方法演示： public class String_Demo03 { public static void main(String[] args) { //创建字符串对象 String s = \"abcde\"; // char[] toCharArray():把字符串转换为字符数组 char[] chs = s.toCharArray(); for(int x = 0; x &lt; chs.length; x++) { System.out.println(chs[x]); } System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\"); // byte[] getBytes ():把字符串转换为字节数组 byte[] bytes = s.getBytes(); for(int x = 0; x &lt; bytes.length; x++) { System.out.println(bytes[x]); } System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\"); // 替换字母it为大写IT String str = \"hellow world\"; String replace = str.replace(\"hellow\", \"HI\"); System.out.println(replace); System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\"); } } 分割功能的方法： public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。 static关键字关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 类变量(静态变量)当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 类变量：使用 static关键字修饰的成员变量。 定义格式： static 数据类型 变量名； 成员变量和类变量的关系区别； 两个变量的生命周期不同 ​成员变量随着对象的创建而存在，随着对象的回收而释放。静态变量随着类的加载而存在，随着类的消失而消失。 调用方式不同 成员变量只能被对象调用。静态变量可以被对象调用，还可以被类名调用。 别名不同 ​成员变量也称为实例变量。 静态变量也称为类变量。 数据存储位置不同 ​成员变量存储在堆内存的对象中，所以也叫对象的特有数据。静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。 静态方法当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。 类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。 定义格式： 修饰符 static 返回值类型 方法名 (参数列表){ // 执行语句 }调用注意事项 静态方法可以直接访问类变量和静态方法。 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。 静态方法中，不能使用this关键字。 tip:静态方法只能访问静态成员调用格式被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。格式： // 访问类变量 类名.类变量名； // 调用静态方法 类名.静态方法名(参数)； tip:static 修饰的内容： 是随着类的加载而加载的，且只加载一次。 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。 静态代码块定义在成员位置，使用static修饰的代码块{ }。 位置：类中方法外。 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。格式：public class ClassName{ static { // 执行语句 } } 作用：给类变量进行初始化赋值实例：public class Game { public static int number; public static ArrayList&lt;String&gt; list; static { // 给类变量赋值 number = 2; list = new ArrayList&lt;String&gt;(); // 添加元素到集合中 list.add(\"a\"); list.add(\"b\"); } } tips:static 关键字，可以修饰变量、方法和代码块。在使用的过程中，**其主要目的还是想在不创建对象的情况下，去调用方法。** Arrays类概述java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。**其所有方法均为静态方法**，调用起来非常简单。 常用的方法 public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。 public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。 Math类概述java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 常用的方法 public static double abs(double a) ：返回 double 值的绝对值。 public static double floor(double a) ：返回小于等于参数最大的整数。 public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法） 继承概述定义： 就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。优点： 提高代码的复用性。 类与类之间产生了关系，是多态的前提。 格式： class 父类 { ... } class 子类 extends 父类 { ... } 继承后的特点——成员变量 成员变量不重名如果子类父类中出现不重名的成员变量，这时的访问是没有影响的 成员变量重名如果子类父类中出现重名的成员变量，这时的访问是有影响的,子类成员变量将父类的覆盖。 子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用super关键字，修饰父类成员变量，类似于this。使用格式： super.父类成员变量名 tip:父类中的成员变量是非私有的，子类中可以直接访问。若父类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？可以在父类中提供公共的getXxx方法和setXxx方法。 继承后的特点——成员方法 成员方法不重名如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。 成员方法重名如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。 重写： 子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写优点：子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。例子： class Phone { public void sendMessage(){ System.out.println(\"发短信\"); } public void call(){ System.out.println(\"打电话\"); } public void showNum(){ System.out.println(\"来电显示号码\"); } } //智能手机类 class NewPhone extends Phone { //重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能 public void showNum(){ //调用父类已经存在的功能使用super super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println(\"显示来电姓名\"); System.out.println(\"显示头像\"); } } tip：这里重写时，用到super.父类成员方法，表示调用父类的成员方法 继承后的特点——构造方法 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。 继承的类型 抽象类概述父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 abstract使用格式抽象方法 使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。定义： 修饰符 abstract 返回值类型 方法名 (参数列表)； 抽象类如果一个类包含抽象方法，那么该类必须是抽类。 定义格式： abstract class 类名字 { } 抽象类的使用继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 接口概述接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。 接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。 引用数据类型：数组，类，接口。 接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 定义格式public interface 接口名称 { // 抽象方法 // 默认方法 // 静态方法 // 私有方法 } 含有抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。 含有默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。 含有静态方法：使用 static 修饰，供接口直接调用。 含有私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。 基本的实现类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。非抽象子类实现接口： 必须重写接口中所有抽象方法。 继承了接口的默认方法，即可以直接调用，也可以重写。实现格式：class 类名 implements 接口名 { // 重写接口中抽象方法【必须】 // 重写接口中默认方法【可选】 } 抽象方法的使用 必须全部实现，代码如下： 定义接口： public interface LiveAble { // 定义抽象方法 public abstract void eat(); public abstract void sleep(); } 定义实现类： public class Animal implements LiveAble { @Override public void eat() { System.out.println(\"吃东西\"); } @Override public void sleep() { System.out.println(\"晚上睡\"); } } 定义测试类： public class InterfaceDemo { public static void main(String[] args) { // 创建子类对象 Animal a = new Animal(); // 调用实现后的方法 a.eat(); a.sleep(); } } 输出结果： 吃东西 晚上睡 默认方法的使用可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 继承默认方法，代码如下：定义接口：public interface LiveAble { public default void fly(){ System.out.println(\"天上飞\"); } } 定义实现类: public class Animal implements LiveAble { // 继承，什么都不用写，直接调用 } 定义测试类：public class InterfaceDemo { public static void main(String[] args) { // 创建子类对象 Animal a = new Animal(); // 调用默认方法 a.fly(); } } 输出结果： 天上飞 重写默认方法，代码如下：定义接口：public interface LiveAble { public default void fly(){ System.out.println(\"天上飞\"); } } 定义实现类:public class Animal implements LiveAble { @Override public void fly() { System.out.println(\"自由自在的飞\"); } } 定义测试类：public class InterfaceDemo { public static void main(String[] args) { // 创建子类对象 Animal a = new Animal(); // 调用重写方法 a.fly(); } } 输出结果： 自由自在的飞 静态方法的使用静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用，代码如下：定义接口： public interface LiveAble { public static void run(){ System.out.println(\"跑起来~~~\"); } } 定义实现类： public class Animal implements LiveAble { // 无法重写静态方法 } 定义测试类： public class InterfaceDemo { public static void main(String[] args) { // Animal.run(); // 【错误】无法继承方法,也无法调用 LiveAble.run(); // } } 输出结果： 跑起来~~~ 私有方法的使用 私有方法：只有默认方法可以调用。 私有静态方法：默认方法和静态方法可以调用。 如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法 去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。 定义接口： public interface LiveAble { default void func(){ func1(); func2(); } private void func1(){ System.out.println(\"跑起来~~~\"); } private void func2(){ System.out.println(\"跑起来~~~\"); } } 接口的多实现在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。实现格式： class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... { // 重写接口中抽象方法【必须】 // 重写接口中默认方法【不重名时可选】 } 抽象方法接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。代码如下：定义多个接口： interface A { public abstract void showA(); public abstract void show(); } interface B { public abstract void showB(); public abstract void show(); } 定义实现类： public class C implements A,B{ @Override public void showA() { System.out.println(\"showA\"); } @Override public void showB() { System.out.println(\"showB\"); } @Override public void show() { System.out.println(\"show\"); } } 默认方法 接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。代码如下：定义多个接口： interface A { public default void methodA(){} public default void method(){} } interface B { public default void methodB(){} public default void method(){} } 定义实现类： public class C implements A,B{ @Override public void method() { System.out.println(\"method\"); } } 静态方法接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。优先级的问题当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下：定义接口： interface A { public default void methodA(){ System.out.println(\"AAAAAAAAAAAA\"); } } 定义父类： class D { public void methodA(){ System.out.println(\"DDDDDDDDDDDD\"); } } 定义子类： class C extends D implements A { // 未重写methodA方法 } 定义测试类： public class Test { public static void main(String[] args) { C c = new C(); c.methodA(); } } 输出结果: DDDDDDDDDDDD 接口的多继承一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。代码如下： 定义父接口： interface A { public default void method(){ System.out.println(\"AAAAAAAAAAAAAAAAAAA\"); } } interface B { public default void method(){ System.out.println(\"BBBBBBBBBBBBBBBBBBB\"); } } 定义子接口： interface D extends A,B{ @Override public default void method() { System.out.println(\"DDDDDDDDDDDDDD\"); } } tips：子接口重写默认方法时，default关键字可以保留。子类重写默认方法时，default关键字不可以保留。 接口与类的相似点和区别相似点 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中 接口与类的区别 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口的特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 多态概述多态是继封装、继承之后，面向对象的第三大特性。生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。定义： 多态：是指同一行为，具有多个不同表现形式。前提： 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 多态的体现格式： 父类类型 变量名 = new 子类对象； 变量名.方法名(); 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 代码如下: Fu f = new Zi(); f.method();当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。 代码如下：定义父类： ```java public abstract class Animal { public abstract void eat(); } 定义子类： class Cat extends Animal { public void eat() { System.out.println(\"吃鱼\"); } } class Dog extends Animal { public void eat() { System.out.println(\"吃骨头\"); } } 定义测试类： public class Test { public static void main(String[] args) { // 多态形式，创建对象 Animal a1 = new Cat(); // 调用的是 Cat 的 eat a1.eat(); // 多态形式，创建对象 Animal a2 = new Dog(); // 调用的是 Dog 的 eat a2.eat(); } } 多态的好处实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下： 定义父类： public abstract class Animal { public abstract void eat(); } 定义子类： class Cat extends Animal { public void eat() { System.out.println(\"吃鱼\"); } } class Dog extends Animal { public void eat() { System.out.println(\"吃骨头\"); } } 定义测试类： public class Test { public static void main(String[] args) { // 多态形式，创建对象 Cat c = new Cat(); Dog d = new Dog(); // 调用showCatEat showCatEat(c); // 调用showDogEa showDogEat(d); /* 以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代 而执行效果一致 */ showAnimalEat(c); showAnimalEat(d); } public static void showCatEat (Cat c){ c.eat(); } public static void showDogEat (Dog d){ d.eat(); } public static void showAnimalEat (Animal a){ a.eat(); } } 由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。 引用类型的转换多态的转型分为向上转型和向下转型向上转型 向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。 使用格式： 父类类型 变量名 = new 子类类型(); 如：Animal a = new Cat(); 向下转型 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 使用格式： 子类类型 变量名 = (子类类型) 父类变量名; 如:Cat c =(Cat) a; 为什么要转型当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 转型演示，代码如下：定义类 abstract class Animal { abstract void eat(); } class Cat extends Animal { public void eat() { System.out.println(\"吃鱼\"); } public void catchMouse() { System.out.println(\"抓老鼠\"); } } class Dog extends Animal { public void eat() { System.out.println(\"吃骨头\"); } public void watchHouse() { System.out.println(\"看家\"); } } 定义测试类： public class Test { public static void main(String[] args) { // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse } } 转型的异常转型的过程中，遇到的问题： public class Test { public static void main(String[] args) { // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】 } } 这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 变量名 instanceof 数据类型 如果变量属于该数据类型，返回true。 如果变量不属于该数据类型，返回false。 所以转换之前最好进行判断： public class Test { public static void main(String[] args) { // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat){ Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse } else if (a instanceof Dog){ Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse } } } final关键字概述学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了final 关键字，用于修饰不可改变内容。 final:不可改变，可用于修饰类，方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，不能被重新赋值。 使用方式修饰类 final class 类名 { } 修饰方法 修饰符 final 返回值类型 方法名(参数列表){ //方法体 } 修饰变量 权限修饰符概述在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限， public：公共的。 protected：受保护的 default：默认的 private：私有的 不同访问权限的访问能力 public protected default private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 可见，public具有最大权限。private则是最小权限。编写代码时，如果没有特殊的考虑，建议这样使用权限： 成员变量使用 private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用 public ，方便调用方法 tip:不加权限修饰符，其访问能力与default修饰符相同 内部类概述将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。 成员内部类 成员内部类 ：定义在类中方法外的类。 格式： class 外部类 { class 内部类{ } } 在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。例如： lass Car { //外部类 class Engine { //内部类 } } 访问特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 创建内部类对象格式： 外部类名.内部类名 对象名 = new 外部类型().new 内部类型()； 访问演示如下：定义类： public class Person { private boolean live = true; class Heart { public void jump() { // 直接访问外部类成员 if (live) { System.out.println(\"心脏在跳动\"); } else { System.out.println(\"心脏不跳了\"); } } } public boolean isLive() { return live; } public void setLive(boolean live) { this.live = live; } } 定义测试类： public class InnerDemo { public static void main(String[] args) { // 创建外部类对象 Person p = new Person(); // 创建内部类对象 Heart heart = p.new Heart(); // 调用内部类方法 heart.jump(); // 调用外部类方法 p.setLive(false); // 调用内部类方法 heart.jump(); } } 输出结果: 心脏在跳动 心脏不跳了 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，Person$Heart.class 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 class People{ public People() { } } class Man{ public Man(){ } public People getWoman(){ class Woman extends People{ //局部内部类 int age =0; } return new Woman(); } } 注意：局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。 匿名内部类 匿名内部类：是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作， 定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。前提 匿名内部类必须继承一个父类或者实现一个父接口。格式 new 父类名或者接口名(){ // 方法重写 @Override public void method() { // 执行语句 } }; 使用方式以抽象类为例，匿名内部类的使用，代码如下：定义抽象类： public abstract class FlyAble{ public abstract void fly(); } 创建匿名内部类，并调用： public class InnerDemo { public static void main(String[] args) { /* 1.等号右边:是匿名内部类，定义并创建该接口的子类对象 2.等号左边:是多态赋值,接口类型引用指向子类对象 */ FlyAble f = new FlyAble(){ public void fly() { System.out.println(\"我飞了~~~\"); } }; //调用 fly方法,执行重写后的方法 f.fly(); } } 通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下： public class InnerDemo2 { public static void main(String[] args) { /* 1.等号右边:定义并创建该接口的子类对象 2.等号左边:是多态,接口类型引用指向子类对象 */ FlyAble f = new FlyAble(){ public void fly() { System.out.println(\"我飞了~~~\"); } }; // 将f传递给showFly方法中 showFly(f); } public static void showFly(FlyAble f) { f.fly(); } } 以上两步，也可以简化为一步，代码如下： ```java public class InnerDemo3 { public static void main(String[] args) { /* 创建匿名内部类,直接传递给showFly(FlyAble f) */ showFly( new FlyAble(){ public void fly() { System.out.println(\"我飞了~~~\"); } }); } public static void showFly(FlyAble f) { f.fly(); } } 引用类型用法总结class作为成员变量在定义一个Role（游戏角色）时，代码如下： class Role { int id; // 角色id int blood; // 生命值 String name; // 角色名称 } 使用 int 类型表示 角色id和生命值，使用 String 类型表示姓名。此时， String 本身就是引用类型，由于使用的方式类似常量，所以往往忽略了它是引用类型的存在。如果我们继续丰富这个类的定义，给 Role 增加武器，穿戴装备等属性，我们将如何编写呢？定义武器类，将增加攻击能力： class Weapon { String name； // 武器名称 int hurt； // 伤害值 } 定义穿戴盔甲类，将增加防御能力，也就是提升生命值： class Armour { String name；// 装备名称 int protect；// 防御值 } 定义角色类： class Role { int id； int blood； String name； // 添加武器属性 Weapon wp； // 添加盔甲属性 Armour ar； // 提供get/set方法 public Weapon getWp() { return wp; } public void setWeapon(Weapon wp) { this.wp = wp; } public Armour getArmour() { return ar; } public void setArmour(Armour ar) { this.ar = ar; } // 攻击方法 public void attack(){ System.out.println(\"使用\"+ wp.getName() +\", 造成\"+wp.getHurt()+\"点伤害\"); } // 穿戴盔甲 public void wear(){ // 增加防御,就是增加blood值 this.blood += ar.getProtect(); System.out.println(\"穿上\"+ar.getName()+\", 生命值增加\"+ar.getProtect()); } } 测试类： public class Test { public static void main(String[] args) { // 创建Weapon 对象 Weapon wp = new Weapon(\"屠龙刀\" , 999999); // 创建Armour 对象 Armour ar = new Armour(\"麒麟甲\",10000); // 创建Role 对象 Role r = new Role(); // 设置武器属性 r.setWeapon(wp); // 设置盔甲属性 r.setArmour(ar); // 攻击 r.attack(); // 穿戴盔甲 r.wear(); } } 输出结果: 使用屠龙刀,造成999999点伤害 穿上麒麟甲 ,生命值增加10000 类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。 interface作为成员变量接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在Role 中，可以增加接口作为成员变量，来设置不同的技能。定义接口： // 法术攻击 public interface FaShuSkill { public abstract void faShuAttack(); } 定义角色类： public class Role { FaShuSkill fs; public void setFaShuSkill(FaShuSkill fs) { this.fs = fs; } // 法术攻击 public void faShuSkillAttack(){ System.out.print(\"发动法术攻击:\"); fs.faShuAttack(); System.out.println(\"攻击完毕\"); } 定义测试类： public class Test { public static void main(String[] args) { // 创建游戏角色 Role role = new Role(); // 设置角色法术技能 role.setFaShuSkill(new FaShuSkill() { @Override public void faShuAttack() { System.out.println(\"纵横天下\"); } }); // 发动法术攻击 role.faShuSkillAttack(); // 更换技能 role.setFaShuSkill(new FaShuSkill() { @Override public void faShuAttack() { System.out.println(\"逆转乾坤\"); } }); // 发动法术攻击 role.faShuSkillAttack(); } } 输出结果: 发动法术攻击:纵横天下 攻击完毕 发动法术攻击:逆转 攻击完毕 我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。 interface作为方法参数和返回值类型例子： 获取某集合中所有的偶数。定义方法： public static List&lt;Integer&gt; getEvenNum(List&lt;Integer&gt; list) { // 创建保存偶数的集合 ArrayList&lt;Integer&gt; evenList = new ArrayList&lt;&gt;(); // 遍历集合list,判断元素为偶数,就添加到evenList中 for (int i = 0; i &lt; list.size(); i++) { Integer integer = list.get(i); if (integer % 2 == 0) { evenList.add(integer); } } /* 返回偶数集合 因为getEvenNum方法的返回值类型是List,而ArrayList是List的子类, 所以evenList可以返回 */ return evenList; } 调用方法： public class Test { public static void main(String[] args) { // 创建ArrayList集合,并添加数字 ArrayList&lt;Integer&gt; srcList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { srcList.add(i); } /* 获取偶数集合 因为getEvenNum方法的参数是List,而ArrayList是List的子类, 所以srcList可以传递 */ List list = getEvenNum(srcList); System.out.println(list); } } 接口作为参数时，传递它的子类对象。接口作为返回值类型时，返回它的子类对象。 object类概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： public class MyClass /*extends Object*/ { // ... } 几个重要的方法 1.toString方法：返回该对象的字符串表 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。一般是用覆盖重写 覆盖重写：如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： public class Person { private String name; private int age; @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } // 省略构造器与Getter Setter } equals方法：指示其他某个对象是否与此对象“相等”。如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： import java.util.Objects; public class Person { private String name; private int age; @Override public boolean equals(Object o) { // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); } } 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： 时间日期类Date类 java.util.Date类 表示特定的瞬间，精确到毫秒 常用方法:Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法 由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： import java.text.DateFormat; import java.text.SimpleDateFormat; public class Demo02SimpleDateFormat { public static void main(String[] args) { // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); } } 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法 使用format方法的代码为： import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; /* 把Date对象转换成String */ public class Demo03DateFormatMethod { public static void main(String[] args) { Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); } parse方法 使用parse方法的代码为： import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /* 把String转换成Date对象 */ public class Demo04DateFormatMethod { public static void main(String[] args) throws ParseException { DateFormat dh = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str2 = \"2021年6月11日\"; Date date1 = dh.parse(str2); System.out.println(date); // } } Calendar类概念java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： import java.util.Calendar; public class Demo06CalendarInit { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); } } 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： import java.util.Calendar; public class CalendarUtil { public static void main(String[] args) { // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); } } import java.util.Calendar; public class Demo07CalendarMethod { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 } } add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： import java.util.Calendar; public class Demo08CalendarMethod { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); } } getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 import java.util.Calendar; import java.util.Date; public class Demo09CalendarMethod { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); } } Tip： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 Collection集合集合概述 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有什么区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map. Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 大致结构如图： 1.3 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。方法演示：import java.util.ArrayList; import java.util.Collection; public class Demo1Collection { public static void main(String[] args) { // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add(\"小李广\"); coll.add(\"扫地僧\"); coll.add(\"石破天\"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println(\"判断 扫地僧 是否在集合中\"+coll.contains(\"扫地僧\")); //boolean remove(E e) 删除在集合中的o元素 System.out.println(\"删除石破天：\"+coll.remove(\"石破天\")); System.out.println(\"操作之后集合中元素:\"+coll); // size() 集合中有几个元素 System.out.println(\"集合中有\"+coll.size()+\"个元素\"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) { System.out.println(objects[i]); } // void clear() 清空集合 coll.clear(); System.out.println(\"集合中内容为：\"+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); } } Set和List的区别 Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。 List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 Iterator迭代器Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： public class IteratorDemo { public static void main(String[] args) { // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(\"串串星人\"); coll.add(\"吐槽星人\"); coll.add(\"汪星人\"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext()){ //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); } } } tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 迭代器的实现原理。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： for(元素的数据类型 变量 : Collection集合or数组){ //写操作代码 } 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 遍历数组public class NBForDemo1 { public static void main(String[] args) { int[] arr = {3,5,6,87}; //使用增强for遍历数组 for(int a : arr){//a代表数组中的每个元素 System.out.println(a); } } } 遍历集合public class NBFor { public static void main(String[] args) { Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(\"小河神\"); coll.add(\"老河神\"); coll.add(\"神婆\"); //使用增强for遍历 for(String s :coll){//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); } } } tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 泛型泛型概述学习集合时，集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。 下面代码： public class GenericDemo { public static void main(String[] args) { Collection coll = new ArrayList(); coll.add(\"abc\"); coll.add(\"it\"); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext()){ //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); } } } 程序在运行时发生了问题java.lang.ClassCastException。 会发生类型转换的异常 ，原因分析：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时ClassCastException。 Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 使用泛型的好处泛型的好处 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： public class GenericDemo2 { public static void main(String[] args) { Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"abc\"); list.add(\"it\"); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); } } } tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 泛型的定义与使用泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 修饰符 class 类名&lt;代表泛型的变量&gt; { } 例如，API中的ArrayList集合： class ArrayList&lt;E&gt;{ public boolean add(E e){ } public E get(int index){ } .... } 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： class ArrayList&lt;String&gt;{ public boolean add(String e){ } public String get(int index){ } ... } 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： class ArrayList&lt;Integer&gt; { public boolean add(Integer e) { } public Integer get(int index) { } ... } 自定义泛型类 public class MyGenericClass&lt;MVP&gt; { //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) { this.mvp = mvp; } public MVP getMVP() { return mvp; } } 使用: public class GenericClassDemo { public static void main(String[] args) { // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP(\"kb\"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); } } 含有泛型的方法定义格式： 修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ } 例如， public class MyGenericMethod { public &lt;MVP&gt; void show(MVP mvp) { System.out.println(mvp.getClass()); } public &lt;MVP&gt; MVP show2(MVP mvp) { return mvp; } } 使用格式：调用方法时，确定泛型的类型 public class GenericMethodDemo { public static void main(String[] args) { // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(\"aaa\"); mm.show(123); mm.show(12.45); } } 含有泛型的接口定义格式： 修饰符 interface接口名&lt;代表泛型的变量&gt; { } 例如， public interface MyGenericInterface&lt;E&gt;{ public abstract void add(E e); public abstract E getE(); } 使用格式： 1、定义类时确定泛型的类型 例如 public class MyImp1 implements MyGenericInterface&lt;String&gt; { @Override public void add(String e) { // 省略... } @Override public String getE() { return null; } } 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; { @Override public void add(E e) { // 省略... } @Override public E getE() { return null; } } 确定泛型： /* * 使用 */ public class GenericInterface { public static void main(String[] args) { MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(\"aa\"); } } 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 例子： public static void main(String[] args) { Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2); } public static void getElement(Collection&lt;?&gt; coll){} //？代表可以接收任意类型 tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 public static void main(String[] args) { Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); } // 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类 public static void getElement1(Collection&lt;? extends Number&gt; coll){} // 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类 public static void getElement2(Collection&lt;? super Number&gt; coll){} List集合我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？ 接下来，我们一起学习Collection中的常用几个子类（java.util.List集合、java.util.Set集合）。 List接口介绍java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 看完API，我们总结一下： List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List的子类ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 但是开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。 LinkedList集合java.util.LinkedList`集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，双向链表的结构如图： 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。方法演示： public class LinkedListDemo { public static void main(String[] args) { LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); //添加元素 link.addFirst(\"abc1\"); link.addFirst(\"abc2\"); link.addFirst(\"abc3\"); System.out.println(link); // 获取元素 System.out.println(link.getFirst()); System.out.println(link.getLast()); // 删除元素 System.out.println(link.removeFirst()); System.out.println(link.removeLast()); while (!link.isEmpty()) { //判断集合是否为空 System.out.println(link.pop()); //弹出集合中的栈顶元素 } System.out.println(link); } } Set接口java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 Set集合有多个子类，这里介绍java.util.HashSet、java.util.LinkedHashSet这两个集合。 tips:Set集合取出元素的方式可以采用：迭代器、增强for。 HashSet集合java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持。HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 tips: 重复元素HashSet集合不储存 HashSet集合存储数据的结构（哈希表）什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 tip:红黑树 ： 每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点（NIL）是黑色。 注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！ 如果一个节点是红色的，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 存储流程图： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 HashSet存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义Student类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); } @Override public int hashCode() { return Objects.hash(name, age); } } public class HashSetDemo2 { public static void main(String[] args) { //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(\"于谦\", 43); stuSet.add(stu); stuSet.add(new Student(\"郭德纲\", 44)); stuSet.add(new Student(\"于谦\", 43)); stuSet.add(new Student(\"郭麒麟\", 23)); stuSet.add(stu); for (Student stu2 : stuSet) { System.out.println(stu2); } } } 执行结果： Student [name=郭德纲, age=44] Student [name=于谦, age=43] Student [name=郭麒麟, age=23] LinkedHashSet我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: public class LinkedHashSetDemo { public static void main(String[] args) { Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(\"bbb\"); set.add(\"aaa\"); set.add(\"abc\"); set.add(\"bbc\"); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } } 结果： bbb aaa abc bbc Collections常用功能 java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码演示： public class CollectionsDemo { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //原来写法 //list.add(12); //list.add(14); //list.add(15); //list.add(1000); //采用工具类 完成 往集合中添加元素 Collections.addAll(list, 5, 222, 1，2); System.out.println(list); //排序方法 Collections.sort(list); System.out.println(list); } } 结果： [5, 222, 1, 2] [1, 2, 5, 222] 这样的顺序是采用默认的顺序，如果想要指定顺序则用这个方法，public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。 Comparator比较器我们还是先研究这个方法 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 不过这次存储的是字符串类型。 public class CollectionsDemo2 { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"cba\"); list.add(\"aba\"); list.add(\"sba\"); list.add(\"nba\"); //排序方法 Collections.sort(list); System.out.println(list); } } 结果： [aba, cba, nba, sba] 我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？ 说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候在去选择的java.util.Comparator接口完成。 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是： public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）如果要按照降序排序则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 操作如下: public class CollectionsDemo3 { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"cba\"); list.add(\"aba\"); list.add(\"sba\"); list.add(\"nba\"); //排序方法 按照第一个单词的降序 Collections.sort(list, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o2.charAt(0) - o1.charAt(0); } }); System.out.println(list); } } 结果如下： [sba, nba, cba, aba] 简述Comparable和Comparator两个接口的区别。Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 Map集合概述现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 Map常用子类通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 **HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 **LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 Map接口中的常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map接口的方法演示 public class MapDemo { public static void main(String[] args) { //创建 map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素到集合 map.put(\"xx\", \"zz\"); map.put(\"kk\", \"bb\"); map.put(\"aa\", \"gg\"); System.out.println(map); //String remove(String key) System.out.println(map.remove(\"kk\")); System.out.println(map); // 查看 System.out.println(map.get(\"xx\")); System.out.println(map.get(\"aa\")); } } tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 Map集合遍历键找值方式键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 代码演示： public class MapDemo01 { public static void main(String[] args) { //创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //添加元素到集合 map.put(\"xx\", \"zz\"); map.put(\"kk\", \"bb\"); map.put(\"aa\", \"gg\"); //获取所有的键 获取键集 Set&lt;String&gt; keys = map.keySet(); // 遍历键集 得到 每一个键 for (String key : keys) { //key 就是键 //获取对应值 String value = map.get(key); System.out.println(key+\"：\"+value); } } } Entry键值对对象我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() public class MapDemo02 { public static void main(String[] args) { // 创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); // 添加元素到集合 map.put(\"xx\", \"zz\"); map.put(\"kk\", \"bb\"); map.put(\"aa\", \"gg\"); // 获取 所有的 entry对象 entrySet Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet(); // 遍历得到每一个entry对象 for (Entry&lt;String, String&gt; entry : entrySet) { // 解析 String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\":\"+value); } } } tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 LinkedHashMap我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。 异常概念 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,把异常的简单类名,拷贝到API中去查。 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 public class ArrayTools { // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) { int element = arr[index]; return element; } } 测试类 public class ExceptionDemo { public static void main(String[] args) { int[] arr = { 34, 12, 67 }; intnum = ArrayTools.getElement(arr, 4) System.out.println(\"num=\" + num); System.out.println(\"over\"); } } 上述程序执行过程图解： 异常的处理 ava异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： throw new 异常类名(参数); 例如： throw new NullPointerException(\"要访问的arr数组不存在\"); throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 public class ThrowDemo { public static void main(String[] args) { //创建一个数组 int[] arr = {2,4,52,2}; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(\"over\"); } /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index){ //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1){ /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\"); } int element = arr[index]; return element; } } 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： public static &lt;T&gt; T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{ } 声明异常的代码演示： public class ThrowsDemo { public static void main(String[] args) throws FileNotFoundException { read(\"a.txt\"); } // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException { if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); } } } throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 public class ThrowsDemo2 { public static void main(String[] args) throws IOException { read(\"a.txt\"); } public static void read(String path)throws FileNotFoundException, IOException { if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); } if (!path.equals(\"b.txt\")) { throw new IOException(); } } } 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： try{ 编写可能会出现异常的代码 }catch(异常类型 e){ 处理异常的代码 //记录日志/打印异常信息/继续抛出异常 } try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： public class TryCatchDemo { public static void main(String[] args) { try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); } catch (FileNotFoundException e) {// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); } System.out.println(\"over\"); } /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException { if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); } } } 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： public class TryCatchDemo4 { public static void main(String[] args) { try { read(\"a.txt\"); } catch (FileNotFoundException e) { //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); } finally { System.out.println(\"不管程序怎样，这里都将会被执行。\"); } System.out.println(\"over\"); } /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException { if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); } } } 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： try{ 编写可能会出现异常的代码 }catch(异常类型A e){ 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常 }catch(异常类型B e){ 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常 } 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 自定义异常 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： // 业务逻辑异常 public class RegisterException extends Exception { /** * 空参构造 */ public RegisterException() { } /** * * @param message 表示异常提示 */ public RegisterException(String message) { super(message); } } 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 public class Demo { // 模拟数据库中已存在账号 private static String[] names = {\"bill\",\"hill\",\"jill\"}; public static void main(String[] args) { //调用方法 try{ // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 }catch(RegisterException e){ //处理异常 e.printStackTrace(); } } //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException{ for (String name : names) { if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常 throw new RegisterException(\"亲\"+name+\"已经被注册了！\"); } } return true; } } 线程 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 Thread类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。 构造方法： public Thread() :分配一个新的线程对象。 public Thread(String name) :分配一个指定名字的新的线程对象。 public Thread(Runnable target) :分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName() :获取当前线程名称。 public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run() :此线程要执行的任务在此处定义代码。 public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 Runnable接口采用 java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动线程。 代码如下： public class MyRunnable implements Runnable{ @Override public void run() { for (int i = 0; i &lt; 20; i++) { System.out.println(Thread.currentThread().getName()+\" \"+i); } } } public class Demo { public static void main(String[] args) { //创建自定义类对象 线程任务对象 MyRunnable mr = new MyRunnable(); //创建线程对象 Thread t = new Thread(mr, \"小强\"); t.start(); for (int i = 0; i &lt; 20; i++) { System.out.println(\"旺财 \" + i); } } } 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：public class NoNameInnerClassThread { public static void main(String[] args) { // new Runnable(){ // public void run(){ // for (int i = 0; i &lt; 20; i++) { // System.out.println(\"张宇:\"+i); // } // } // }; //‐‐‐这个整体 相当于new MyRunnable() Runnable r = new Runnable(){ public void run(){ for (int i = 0; i &lt; 20; i++) { System.out.println(\"张宇:\"+i); } } }; new Thread(r).start(); for (int i = 0; i &lt; 20; i++) { System.out.println(\"费玉:\"+i); } } } 线程安全当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。要解决上述多线程并发访问一个资源的安全性问题,Java中提供了同步机制(synchronized)来解决。那么怎么去使用呢？有三种方式完成同步操作： 同步代码块。 同步方法。 锁机制。同步代码块 **同步代码块:**synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: synchronized(同步锁){ 需要同步操作的代码 } 同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 使用同步代码块解决代码：(卖票案例) public class Ticket implements Runnable{ private int ticket = 100; Object lock = new Object(); /* * 执行卖票操作 */ @Override public void run() { //每个窗口卖票的操作 //窗口 永远开启 while(true){ synchronized (lock) { if(ticket&gt;0){//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try { Thread.sleep(50); } catch (InterruptedException e) { // TODO Auto‐generated catch block e.printStackTrace(); } //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+\"正在卖:\"+ticket‐‐); } } } } } 同步方法 同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。格式：public synchronized void method(){ 可能会产生线程安全问题的代码 } 同步锁是谁?对于非static方法,同步锁就是this。对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 public class Ticket implements Runnable{ private int ticket = 100; /* * 执行卖票操作 */ @Override public void run() { //每个窗口卖票的操作 //窗口 永远开启 while(true){ sellTicket(); } } /* * 锁对象 是 谁调用这个方法 就是谁 * 隐含 锁对象 就是 this * */ public synchronized void sellTicket(){ if(ticket&gt;0){//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try { Thread.sleep(100); } catch (InterruptedException e) { // TODO Auto‐generated catch block e.printStackTrace(); Lock锁java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock() :加同步锁。 public void unlock() :释放同步锁。 使用如下： } //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+\"正在卖:\"+ticket‐‐); } } } public class Ticket implements Runnable{ private int ticket = 100; Lock lock = new ReentrantLock(); /* * 执行卖票操作 */ @Override public void run() { //每个窗口卖票的操作 //窗口 永远开启 while(true){ lock.lock(); if(ticket&gt;0){//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try { Thread.sleep(50); } catch (InterruptedException e) { // TODO Auto‐generated catch block e.printStackTrace(); } //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+\"正在卖:\"+ticket‐‐); } lock.unlock(); } } } 线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态： 这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。 Blocked(锁阻 塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 TimedWaiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 Timed Waiting(计时等待)Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)。 BLOCKED（锁阻塞）Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 Waiting（无限等待）Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 等待唤醒机制线程间的通信概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 为什么要处理线程间通信： 多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 如何保证线程间通信有效利用资源： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。 等待唤醒机制什么是等待唤醒机制 这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 就是在一个线程进行了规定操作后，就进入等待状态（wait()**）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。 notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。 总结如下： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态； 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 生产者与消费者问题等待唤醒机制其实就是经典的“生产者与消费者”的问题。 就拿生产包子消费包子来说等待唤醒机制如何有效利用资源： 包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。 代码演示： 包子资源类： public class BaoZi { String pier ; String xianer ; boolean flag = false ;//包子资源 是否存在 包子资源状态 } 吃货线程类： public class ChiHuo extends Thread{ private BaoZi bz; public ChiHuo(String name,BaoZi bz){ super(name); this.bz = bz; } @Override public void run() { while(true){ synchronized (bz){ if(bz.flag == false){//没包子 try { bz.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"吃货正在吃\"+bz.pier+bz.xianer+\"包子\"); bz.flag = false; bz.notify(); } } } } 包子铺线程类： public class BaoZiPu extends Thread { private BaoZi bz; public BaoZiPu(String name,BaoZi bz){ super(name); this.bz = bz; } @Override public void run() { int count = 0; //造包子 while(true){ //同步 synchronized (bz){ if(bz.flag == true){//包子资源 存在 try { bz.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 没有包子 造包子 System.out.println(\"包子铺开始做包子\"); if(count%2 == 0){ // 冰皮 五仁 bz.pier = \"冰皮\"; bz.xianer = \"五仁\"; }else{ // 薄皮 牛肉大葱 bz.pier = \"薄皮\"; bz.xianer = \"牛肉大葱\"; } count++; bz.flag=true; System.out.println(\"包子造好了：\"+bz.pier+bz.xianer); System.out.println(\"吃货来吃吧\"); //唤醒等待线程 （吃货） bz.notify(); } } } } 测试类： public class Demo { public static void main(String[] args) { //等待唤醒案例 BaoZi bz = new BaoZi(); ChiHuo ch = new ChiHuo(\"吃货\",bz); BaoZiPu bzp = new BaoZiPu(\"包子铺\",bz); ch.start(); bzp.start(); } } 执行效果： 包子铺开始做包子 包子造好了：冰皮五仁 吃货来吃吧 吃货正在吃冰皮五仁包子 包子铺开始做包子 包子造好了：薄皮牛肉大葱 吃货来吃吧 吃货正在吃薄皮牛肉大葱包子 包子铺开始做包子 包子造好了：冰皮五仁 吃货来吃吧 吃货正在吃冰皮五仁包子 线程池线程池思想概述我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。 线程池概念 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。(task) 提交Runnable接口子类对象。(take task) 关闭线程池(一般不做)。 Runnable实现类代码： public class MyRunnable implements Runnable { @Override public void run() { System.out.println(\"我要一个教练\"); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"教练来了： \" + Thread.currentThread().getName()); System.out.println(\"教我游泳,交完后，教练回到了游泳池\"); } } 线程池测试类： public class ThreadPoolDemo { public static void main(String[] args) { // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 MyRunnable r = new MyRunnable(); //自己创建线程对象的方式 // Thread t = new Thread(r); // t.start(); ---&gt; 调用MyRunnable中的run() // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 // 将使用完的线程又归还到了线程池中 // 关闭线程池 //service.shutdown(); } } ``` ### Lambda表达式 Lambda省去面向对象的条条框框，格式由**3个部分**组成： * 一些参数 * 一个箭头 * 一段代码 Lambda表达式的**标准格式**为： (参数类型 参数名称) -&gt; { 代码语句 } 格式说明： * 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 * `-&gt;`是新引入的语法格式，代表指向动作。 * 大括号内的语法与传统方法体要求基本一致。 **使用前提** Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 1. 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。 无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一 时，才可以使用Lambda。 2. 使用Lambda必须具有上下文推断。 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 &gt;备注：有且仅有一个抽象方法的接口，称为“函数式接口” &gt; ### File类 #### 概述 `java.io.File` 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 #### 构造方法 * `public File(String pathname) ` ：通过将给定的**路径名字符串**转换为抽象路径名来创建新的 File实例。 * `public File(String parent, String child) ` ：从**父路径名字符串和子路径名字符串**创建新的 File实例。 * `public File(File parent, String child)` ：从**父抽象路径名和子路径名字符串**创建新的 File实例。 * 构造举例，代码如下： ```java // 文件路径名 String pathname = \"D:\\\\aaa.txt\"; File file1 = new File(pathname); // 文件路径名 String pathname2 = \"D:\\\\aaa\\\\bbb.txt\"; File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = \"d:\\\\aaa\"; String child = \"bbb.txt\"; File file3 = new File(parent, child); // 通过父级File对象和子路径字符串 File parentDir = new File(\"d:\\\\aaa\"); String child = \"bbb.txt\"; File file4 = new File(parentDir, child); 小贴士： 一个File对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 方法演示，代码如下： public class FileGet { public static void main(String[] args) { File f = new File(\"d:/aaa/bbb.java\"); System.out.println(\"文件绝对路径:\"+f.getAbsolutePath()); System.out.println(\"文件构造路径:\"+f.getPath()); System.out.println(\"文件名称:\"+f.getName()); System.out.println(\"文件长度:\"+f.length()+\"字节\"); File f2 = new File(\"d:/aaa\"); System.out.println(\"目录绝对路径:\"+f2.getAbsolutePath()); System.out.println(\"目录构造路径:\"+f2.getPath()); System.out.println(\"目录名称:\"+f2.getName()); System.out.println(\"目录长度:\"+f2.length()); } } 输出结果： 文件绝对路径:d:\\aaa\\bbb.java 文件构造路径:d:\\aaa\\bbb.java 文件名称:bbb.java 文件长度:636字节 目录绝对路径:d:\\aaa 目录构造路径:d:\\aaa 目录名称:aaa 目录长度:4096 API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。 绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 public class FilePath { public static void main(String[] args) { // D盘下的bbb.java文件 File f = new File(\"D:\\\\bbb.java\"); System.out.println(f.getAbsolutePath()); // 项目下的bbb.java文件 File f2 = new File(\"bbb.java\"); System.out.println(f2.getAbsolutePath()); } } 输出结果： D:\\bbb.java D:\\idea_project_test4\\bbb.java 判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 方法演示，代码如下： public class FileIs { public static void main(String[] args) { File f = new File(\"d:\\\\aaa\\\\bbb.java\"); File f2 = new File(\"d:\\\\aaa\"); // 判断是否存在 System.out.println(\"d:\\\\aaa\\\\bbb.java 是否存在:\"+f.exists()); System.out.println(\"d:\\\\aaa 是否存在:\"+f2.exists()); // 判断是文件还是目录 System.out.println(\"d:\\\\aaa 文件?:\"+f2.isFile()); System.out.println(\"d:\\\\aaa 目录?:\"+f2.isDirectory()); } } 输出结果： d:\\aaa\\bbb.java 是否存在:true d:\\aaa 是否存在:true d:\\aaa 文件?:false d:\\aaa 目录?:true 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 方法演示，代码如下： public class FileCreateDelete { public static void main(String[] args) throws IOException { // 文件的创建 File f = new File(\"aaa.txt\"); System.out.println(\"是否存在:\"+f.exists()); // false System.out.println(\"是否创建:\"+f.createNewFile()); // true System.out.println(\"是否存在:\"+f.exists()); // true // 目录的创建 File f2= new File(\"newDir\"); System.out.println(\"是否存在:\"+f2.exists());// false System.out.println(\"是否创建:\"+f2.mkdir()); // true System.out.println(\"是否存在:\"+f2.exists());// true // 创建多级目录 File f3= new File(\"newDira\\\\newDirb\"); System.out.println(f3.mkdir());// false File f4= new File(\"newDira\\\\newDirb\"); System.out.println(f4.mkdirs());// true // 文件的删除 System.out.println(f.delete());// true // 目录的删除 System.out.println(f2.delete());// true System.out.println(f4.delete());// false } } API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 public class FileFor { public static void main(String[] args) { File dir = new File(\"d:\\\\java_code\"); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names){ System.out.println(name); } //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) { System.out.println(file); } } } 小贴士： 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 递归概述 递归：指在当前方法内调用自己的这种现象。 递归的分类: 递归分为两种，直接递归和间接递归。 直接递归称为方法自身调用自己。 间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。 注意事项： 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。 构造方法,禁止递归 public class Demo01DiGui { public static void main(String[] args) { // a(); b(1); } /* * 3.构造方法,禁止递归 * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去 */ public Demo01DiGui() { //Demo01DiGui(); } /* * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。 * 4993 * Exception in thread \"main\" java.lang.StackOverflowError */ private static void b(int i) { System.out.println(i); //添加一个递归结束的条件,i==5000的时候结束 if(i==5000){ return;//结束方法 } b(++i); } /* * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread \"main\" * java.lang.StackOverflowError */ private static void a() { System.out.println(\"a方法\"); a(); } } 递归累加求和计算1 ~ n的和分析：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。 实现代码： public class DiGuiDemo { public static void main(String[] args) { //计算1~num的和，使用递归完成 int num = 5; // 调用求和的方法 int sum = getSum(num); // 输出结果 System.out.println(sum); } /* 通过递归算法实现. 参数列表:int 返回值类型: int */ public static int getSum(int num) { /* num为1时,方法返回1, 相当于是方法的出口,num总有是1的情况 */ if(num == 1){ return 1; } /* num不为1时,方法返回 num +(num-1)的累和 递归调用getSum方法 */ return num + getSum(num-1); } } 递归求阶乘 阶乘：所有小于及等于该数的正整数的积。 n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 分析：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。 推理得出：n! = n * (n-1)! 代码实现： public class DiGuiDemo { //计算n的阶乘，使用递归完成 public static void main(String[] args) { int n = 3; // 调用求阶乘的方法 int value = getValue(n); // 输出结果 System.out.println(\"阶乘为:\"+ value); } /* 通过递归算法实现. 参数列表:int 返回值类型: int */ public static int getValue(int n) { // 1的阶乘为1 if (n == 1) { return 1; } /* n不为1时,方法返回 n! = n*(n-1)! 递归调用getValue方法 */ return n * getValue(n - 1); } } 递归打印多级目录分析：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。 代码实现： public class DiGuiDemo2 { public static void main(String[] args) { // 创建File对象 File dir = new File(\"D:\\\\aaa\"); // 调用打印目录方法 printDir(dir); } public static void printDir(File dir) { // 获取子文件和目录 File[] files = dir.listFiles(); // 循环打印 /* 判断: 当是文件时,打印绝对路径. 当是目录时,继续调用打印目录的方法,形成递归调用. */ for (File file : files) { // 判断 if (file.isFile()) { // 是文件,输出文件绝对路径 System.out.println(\"文件名:\"+ file.getAbsolutePath()); } else { // 是目录,输出目录绝对路径 System.out.println(\"目录:\"+file.getAbsolutePath()); // 继续遍历,调用printDir,形成递归 printDir(file); } } } } 文件搜索搜索目录下的.java文件 public class SearchFiles { //文件搜索 public static void main(String[] args) { //创建File对象 File file = new File(\"E:\\\\IdeaProjects\"); //调用打印目录的方法 printDir(file); } //打印目录的方法 public static void printDir(File file){ //获取子文件和目录 File[] files = file.listFiles(); //循环打印该文件下的各个目录 for (File filebb : files){ //如果是文件判断文件的类型则输出文件的绝对路径 if (filebb.isFile()){ //判断文件名是否为.java文件 if (filebb.getName().endsWith(\".java\")){ System.out.println(\"文件路径名为：\"+filebb.getAbsolutePath()); } }else{ //判断为目录,继续递归调用 printDir(filebb); } } } } 文件过滤器优化java.io.FileFilter是一个接口，是File的过滤器。 该接口的对象可以传递给File类的listFiles(FileFilter) 作为参数， 接口中只有一个方法。 boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。 分析： 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。 accept方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： 要么是.java文件。 要么是目录，用于继续遍历。 通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印。 代码实现： public class DiGuiDemo4 { public static void main(String[] args) { File dir = new File(\"D:\\\\aaa\"); printDir2(dir); } public static void printDir2(File dir) { // 匿名内部类方式,创建过滤器子类对象 File[] files = dir.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { return pathname.getName().endsWith(\".java\")||pathname.isDirectory(); } }); // 循环打印 for (File file : files) { if (file.isFile()) { System.out.println(\"文件名:\" + file.getAbsolutePath()); } else { printDir2(file); } } } } Lambda优化分析：FileFilter是只有一个方法的接口，因此可以用lambda表达式简写。 lambda格式： ()-&gt;{ } 代码实现： public static void printDir3(File dir) { // lambda的改写 File[] files = dir.listFiles(f -&gt;{ return f.getName().endsWith(\".java\") || f.isDirectory(); }); // 循环打印 for (File file : files) { if (file.isFile()) { System.out.println(\"文件名:\" + file.getAbsolutePath()); } else { printDir3(file); } } }","categories":[{"name":"语言篇","slug":"语言篇","permalink":"http://inactionzz.github.io/categories/%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://inactionzz.github.io/tags/JAVA/"}],"author":"ZZ"}],"categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://inactionzz.github.io/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"},{"name":"框架篇","slug":"框架篇","permalink":"http://inactionzz.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"},{"name":"博客篇","slug":"博客篇","permalink":"http://inactionzz.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"算法篇","slug":"算法篇","permalink":"http://inactionzz.github.io/categories/%E7%AE%97%E6%B3%95%E7%AF%87/"},{"name":"语言篇","slug":"语言篇","permalink":"http://inactionzz.github.io/categories/%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"nlp","slug":"nlp","permalink":"http://inactionzz.github.io/tags/nlp/"},{"name":"JAVA","slug":"JAVA","permalink":"http://inactionzz.github.io/tags/JAVA/"},{"name":"博客","slug":"博客","permalink":"http://inactionzz.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"http://inactionzz.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://inactionzz.github.io/tags/Github/"},{"name":"Machine learning -","slug":"Machine-learning","permalink":"http://inactionzz.github.io/tags/Machine-learning/"},{"name":"Python","slug":"Python","permalink":"http://inactionzz.github.io/tags/Python/"}]}