{"meta":{"title":"ZZ","subtitle":"ZZのBlog","description":"研究僧 | 计算机技术  ","author":"XZ","url":"http://Inactionzz.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-05-31T03:00:34.021Z","comments":true,"path":"404.html","permalink":"http://inactionzz.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-05-31T03:00:34.167Z","updated":"2021-05-31T03:00:34.167Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://inactionzz.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-05-31T03:00:34.170Z","updated":"2021-05-31T03:00:34.170Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://inactionzz.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-05-31T03:00:34.166Z","comments":true,"path":"about/index.html","permalink":"http://inactionzz.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-05-31T03:00:34.168Z","comments":true,"path":"categories/index.html","permalink":"http://inactionzz.github.io/categories/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-05-31T03:00:34.039Z","comments":true,"path":"List/index.html","permalink":"http://inactionzz.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-05-31T03:00:34.170Z","comments":true,"path":"friends/index.html","permalink":"http://inactionzz.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-05-31T11:12:14.218Z","comments":true,"path":"contact/index.html","permalink":"http://inactionzz.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-05-31T03:00:34.167Z","comments":true,"path":"archives/index.html","permalink":"http://inactionzz.github.io/archives/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-05-31T03:00:34.171Z","comments":true,"path":"resource/index.html","permalink":"http://inactionzz.github.io/resource/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-05-31T03:00:34.168Z","comments":true,"path":"census/index.html","permalink":"http://inactionzz.github.io/census/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-05-31T03:00:34.171Z","comments":true,"path":"tags/index.html","permalink":"http://inactionzz.github.io/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-05-31T03:00:34.040Z","comments":true,"path":"List/movies/index.html","permalink":"http://inactionzz.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-05-31T03:00:34.040Z","comments":true,"path":"List/music/index.html","permalink":"http://inactionzz.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-05-31T03:00:34.029Z","updated":"2021-05-31T03:00:34.029Z","comments":true,"path":"List/galleries/index.html","permalink":"http://inactionzz.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-05-31T03:00:34.042Z","comments":true,"path":"List/tools/index.html","permalink":"http://inactionzz.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-05-31T03:00:34.030Z","updated":"2021-05-31T03:00:34.030Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-05-31T03:00:34.030Z","updated":"2021-05-31T03:00:34.030Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-05-31T03:00:34.031Z","updated":"2021-05-31T03:00:34.031Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-05-31T03:00:34.032Z","updated":"2021-05-31T03:00:34.032Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-05-31T03:00:34.033Z","updated":"2021-05-31T03:00:34.033Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-05-31T03:00:34.034Z","updated":"2021-05-31T03:00:34.034Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-05-31T03:00:34.035Z","updated":"2021-05-31T03:00:34.035Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-05-31T03:00:34.036Z","updated":"2021-05-31T03:00:34.036Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-05-31T03:00:34.037Z","updated":"2021-05-31T03:00:34.037Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-05-31T03:00:34.037Z","updated":"2021-05-31T03:00:34.037Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-05-31T03:00:34.038Z","updated":"2021-05-31T03:00:34.038Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-05-31T03:00:34.038Z","updated":"2021-05-31T03:00:34.038Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://inactionzz.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"随想","slug":"Thought","date":"2021-06-01T03:41:03.000Z","updated":"2021-06-01T06:21:38.413Z","comments":true,"path":"posts/8639fcc6.html","link":"","permalink":"http://inactionzz.github.io/posts/8639fcc6.html","excerpt":"","text":"","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://inactionzz.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://inactionzz.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"ZZ"},{"title":"hexo博客搭建","slug":"new-blog","date":"2021-05-27T03:41:03.000Z","updated":"2021-06-01T09:21:14.781Z","comments":true,"path":"posts/7639fcc6.html","link":"","permalink":"http://inactionzz.github.io/posts/7639fcc6.html","excerpt":"","text":"0x001 简单介绍 基于Hexo框架，采用hexo-theme-matery主题 0x002 Hexo 初级搭建 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git的作用是将本地的网页文件传到github上。 Git下载地址 Git教程 windows： 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择Use Git from the Windows Command Prompt。 2. 安装node.jsHexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。 windows： 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 3. 添加npm国内源使用阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4. 安装Hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 比如我的博客文件都存放在E:\\MyBlog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v验证是否安装成功。 到此为止hexo就安装完了。 接下来初始化一下hexo,即初始化我们的网站，输入hexo init初始化文件夹 hexo init MyBlog 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 到此为止，本地的网站配置完成了。 输入hexo g生成静态网页，然后输入hexo s打开本地服务器 hexo g hexo s 5. 注册Github账号创建个人仓库接下来就去注册一个github账号，用来存放我们的网站。 打开https://github.com/，新建一个项目仓库New repository，如下所示： 然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上 要创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。例如我的：http://LuckyZmj.github.io 6. 生成SSH添加到GitHub生成SSH添加到GitHub，连接Github与本地。右键打开git bash here，然后输入下面命令： git config --global user.name \"注册GitHub用户名\" git config --global user.email \"注册GitHub的邮箱\" 用以下两条，检查一下你有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C \"注册GitHub的邮箱\" 这个时候它会告诉你已经生成了.ssh的文件夹。在git bash中输入 cat ~/.ssh/id_rsa.pub 将输出的内容复制到框中，点击确定保存。 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。如图： 在git bash输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 ssh -T git@github.com 7. 将hexo部署到GitHub将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。找到如下配置进行修改： deploy: type: git repository: https://github.com/LuckyZmj/LuckyZmj.github.io branch: master repository修改为你自己的github项目地址即可，就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save 然后就可以部署提交到github，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西。 hexo generate，生成静态文章，可以用 hexo g缩写 ，hexo deploy部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 8. 写文章和发布文章首先在博客根目录下右键打开git bash here，安装一个扩展npm i hexo-deployer-git。 npm i hexo-deployer-git 然后输入hexo new post \"article title\"，新建一篇文章。 hexo new post \"article title\" 然后打开E:\\MyBlog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件。 另外推荐直接使用有道云编写markdown文章，不仅可以实时预览，还可以快捷的生成markdown语法格式，具体效果如下图所示。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章了。 到此为止，Hexo初级搭建就已经完成了。 0x003 Hexo 优化定制 1. Hexo相关目录文件1.1 博客目录构成介绍node_modules是node.js各种库的目录，public是生成的网页文件目录，scaffolds里面就三个文件，存储着新文章和新页面的初始设置，source是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，themes存放着主题文件，一般也用不到。 我们平时写文章只需要关注source/_posts这个文件夹就行了。 - node_modules - public - scaffolds - source - _data - _posts - about - archives - categories - friends - tags - themes 1.2 hexo基本配置在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 1.2.1 网站参数描述title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言timezone网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 1.2.2 网址参数描述url网址root网站根目录 permalink文章的永久链接格式permalink_defaults永久链接中各部分的默认值 在这里，你需要把url改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。 参数结果 :year/:month/:day/:title /2019/08/10/hello-world :year-:month-:day-:title.html 2019-08-10-hello-world.html :category/:titlefoo /bar/hello-world 2. 定制主题这里推荐作者洪卫的hexo-blog-fly博客主题，该主题是基于hexo-theme-matery优化的，需要把博客相关信息换成您自己的就可以部署了，极大简化了构建博客的工作量和复杂度。 2.1 简单使用方法 安装Git, 安装nodeJS，安装Hexo 你可以直接fork一份源码到你的仓库，clone到本地博客文件夹内 在本地博客仓库运行npm i命令安装依赖包 直接修改配置信息，改成自己的信息 运行命令hexo clean（清除生成文件），hexo g（生成网页）， hexo s（本地预览），hexo d（部署） 2.2 原主题特性: 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 2.3 新增加特性: 修改了原主题的一些很多bug 加入图片懒加载功能，在根目录配置文件开启和关闭 增加留言板功能 在关于板块,加入简历功能页 增加视听[视觉听觉影音]板块 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。 增加网站运行时间显示 增加动漫模型 整体替换Banner图片和文章特色图片 增加分类相册功能 修改了一些控件的参数 修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观 解决首页文章列表卡片上方 border-radius圆角失效的bug 添加页面樱花飘落动效 添加鼠标点击烟花爆炸动效 加入天气接口控件 加入鼠标点击文字特效 添加页面雪花飘落动效 添加在线聊天插件 调整线聊天插件参数，使之能够随着鼠标滑动位置自适应调整 持续更新… 2.4 切换主题如果想自己动手对hexo-theme-matery优化的话，可以修改Hexo根目录下的 _config.yml的 theme 的值 theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 2.5 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： --- title: categories date: 2018-09-30 17:25:30 type: \"categories\" layout: \"categories\" --- 2.6 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： --- title: tags date: 2018-09-30 18:23:38 type: \"tags\" layout: \"tags\" --- 2.7 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： --- title: about date: 2018-09-30 17:25:30 type: \"about\" layout: \"about\" --- 2.8 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，前提是已经开启了第三方评论系统才能显示。如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： --- title: contact date: 2018-09-30 17:25:30 type: \"contact\" layout: \"contact\" --- 2.9 新建友情链接 friends 页（可选的）friends 页是用来展示友情链接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： --- title: friends date: 2018-12-12 21:25:30 type: \"friends\" layout: \"friends\" --- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： [{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\" }] 2.10 一级菜单导航配置配置基本菜单导航的名称、路径url和图标icon 菜单导航名称可以是中文也可以是英文(如：Index或主页) 图标icon 可以在Font Awesome 中查找 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 2.11 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children) 在children下创建二级菜单的 名称name,路径url和图标icon. 注意每个二级菜单模块前要加 -. 注意缩进格式 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件。 2.12 代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： highlight: enable: false prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 更多代码块优化详细内容请访问：http://luckyzmj.cn/posts/1b9a9e28.html 2.13 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： search: path: search.xml field: post 2.14 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount 插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 2.15 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 2.16 添加 RSS 订阅支持（可选的）本主题中还使用到了hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 2.17 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 2.18 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 2.19 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 2.20 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 2.21 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 2.22 配置音乐播放器（可选的）要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可 # 是否在首页显示音乐 music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 server: netease #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 503838841 #require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 提示： server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。 type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id获取示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，地址栏有一串数字，playlist的id即为这串数字。 2.23文章 Front-matter 介绍Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。最简示例 --- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 --- 最全示例 --- title: theme主题介绍 date: 2018-09-07 09:25:00 author: 赵奇 img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- 2.24 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：修改主题颜色 在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： /* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */ .bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); } @-webkit-keyframes rainbow { /* 动态切换背景颜色. */ } @keyframes rainbow { /* 动态切换背景颜色. */ } body { /* background-color: #eaeaea; */ /* 增加背景壁纸*/ background: url(\"https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png\"), url(\"http://luckyzmj.cn/img/yun.jpg\") 0px 0px; background-attachment: fixed; margin: 0; color: #34495e; } 2.25 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 2.26 优化目录栏在 themes\\Matery\\layout\\_partial\\post-detail-toc.ejs，修改内容如下： .toc-widget { padding-left: 20px; width: 345px; background-color: rgb(255, 255, 255,0.7); border-radius: 10px; box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important; } #toc-content { margin-bottom: 20px; } 0x004 更多详细教程以下几篇文章都是基于Hexo框架和hexo-theme-matery主题优化的教程，大家如果遇到问题，可以参考其中的方法。 Hexo+Github博客搭建完全教程 hexo-theme-matery作者教程 Hexo+github搭建博客(超级详细版，精细入微) hexo（matery）背景、滚动条优化+增加点击跳评论0x005 转载声明原文章：http://luckyzmj.cn/posts/e3e08109.html","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://inactionzz.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://inactionzz.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"http://inactionzz.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://inactionzz.github.io/tags/Github/"}],"author":"ZZ"},{"title":"Python","slug":"Python","date":"2020-05-24T03:00:00.000Z","updated":"2021-06-01T06:14:45.096Z","comments":true,"path":"posts/3b3510a4.html","link":"","permalink":"http://inactionzz.github.io/posts/3b3510a4.html","excerpt":"","text":"前言Py学习笔记","categories":[{"name":"语言篇","slug":"语言篇","permalink":"http://inactionzz.github.io/categories/%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://inactionzz.github.io/tags/Python/"}],"author":"ZZ"},{"title":"JAVA","slug":"JAVA","date":"2020-05-24T02:00:00.000Z","updated":"2021-06-18T15:43:44.494Z","comments":true,"path":"posts/4b3510a4.html","link":"","permalink":"http://inactionzz.github.io/posts/4b3510a4.html","excerpt":"","text":"前言JAVA学习笔记 JVM，JRE，JDK JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 JRE(Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库。 JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 tip:三者关系： JDK &gt; JRE &gt; JVM IDEA常用快捷键 快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标位置下面 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释 Alt+Ins 自动生成代码，toString，get，set等方法 Alt+Shift+上下箭头 移动当前代码行 数组 定义方式一：数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度]; 定义方式二：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3…}; 定义方式三：数据类型[] 数组名 = {元素1,元素2,元素3…}; 面向对象概述Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。 类和对象1.类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。现实中，描述一类事物可用：属性：就是该事物的状态信息。行为：就是该事物能够做什么。2.对象：对象：是一类事物的具体体现。对象是类的一个实例 ，必然具备该类事物的属性和行为。3.类和对象的关系： 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 4.类的定义： public class ClassName { //成员变量 //成员方法 } 定义类：就是定义类的成员，包括成员变量和成员方法。成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。成员方法：和以前定义方法几乎是一样的。只不过把static去掉.5.对象的使用创建对象： 类名 对象名 = new 类名(); 使用对象访问类中的成员： 对象名.成员变量； 对象名.成员方法()； 6.成员变量和局部变量的不同 在类中的位置不同 1.成员变量：类中，方法外2.局部变量：方法中或者方法声明上(形式参数) 作用范围不一样 1.成员变量：类中2.局部变量：方法中 初始化值的不同 1.成员变量：有默认值2.局部变量：没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 1.成员变量：堆内存2.局部变量：栈内存 生命周期不同 1.成员变量：随着对象的创建而存在，随着对象的消失而消失2.局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 封装概述面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。封装的原则：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 封装的操作private关键字： private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只在本类中才能访问。 具体的操作： 1.修改属性的可见性来限制对属性的访问（一般限制为private），例如： public class Person { private String name; private int age; } 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 2.对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： public class Person{ private String name; private int age; ​ public int getAge(){ return age; } ​ public String getName(){ return name; } ​ public void setAge(int age){ this.age = age; } ​ public void setName(String name){ this.name = name; } } 封装的优化1. this 关键字：采用this关键字是为了解决局部成员变量和方法的形参变量的重名冲突。使用格式： this.成员变量名； 2. 构造方法：当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。tip：无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。使用格式： 修饰符 构造方法名(参数列表){ // 方法体 } 构造方法名需要与其所在的类名相同实例： public class Student { private String name; private int age; // 无参数构造方法 public Student() {} // 有参数构造方法 public Student(String name,int age) { this.name = name; this.age = age; } } 构造方法可以定义参数也可以不定义。 3.标准代码–JavaBean：JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。 规范的类： public class ClassName{ //成员变量 //无参构造方法【必须】 //有参构造方法【建议】 //成员方法 //getXxx() //setXxx() } Scanner类一个可以解析基本类型和字符串的简单文本扫描器 创建Scanner对象 Scanner s = new Scanner(System.in); 使用next方法接收字符串： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 // next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if (scan.hasNext()) { String str1 = scan.next(); System.out.println(\"输入的数据为：\" + str1); } scan.close(); } } 其中hasNext方法用来判断是否还有输入的数据：用nextline方法接收字符串： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 // nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if (scan.hasNextLine()) { String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\" + str2); } scan.close(); } } tip：next与nextline的区别：next(): 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。next() 不能得到带有空格的字串。 nextLine()： 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 补充：可以用nextxxx获得整形，浮点型等数据类型hasnextxxx用来判断数据类型。 ArrayList类ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。ArrayList 继承了 AbstractList ，并实现了 List 接口格式： ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;(); // 初始化 添加元素的方法：add objectName.add(\"\"); 访问元素的方法： get objectName.get(\"\"); 修改元素的方法： set objectName.set(2, \"Wiki\"); // 第一个参数为索引位置，第二个为要修改的值 修改元素的方法： remove objectName.remove(3); // 删除第四个元素 计算大小： size objectName.size(); 注意：ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下： 基本类型 基本类型包装类 byte Byte short Short int Integer long Long loat Float double Double char Character boolean Boolean String 类字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。 几个常用的方法获取功能的方法： public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。 public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。 转换功能的方法： public char[] toCharArray () ：将此字符串转换为新的字符数组。 public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。 public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。 方法演示： public class String_Demo03 { public static void main(String[] args) { //创建字符串对象 String s = \"abcde\"; // char[] toCharArray():把字符串转换为字符数组 char[] chs = s.toCharArray(); for(int x = 0; x &lt; chs.length; x++) { System.out.println(chs[x]); } System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\"); // byte[] getBytes ():把字符串转换为字节数组 byte[] bytes = s.getBytes(); for(int x = 0; x &lt; bytes.length; x++) { System.out.println(bytes[x]); } System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\"); // 替换字母it为大写IT String str = \"hellow world\"; String replace = str.replace(\"hellow\", \"HI\"); System.out.println(replace); System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\"); } } 分割功能的方法： public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。 static关键字关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 类变量(静态变量)当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 类变量：使用 static关键字修饰的成员变量。 定义格式： static 数据类型 变量名； 成员变量和类变量的关系区别； 两个变量的生命周期不同 ​成员变量随着对象的创建而存在，随着对象的回收而释放。静态变量随着类的加载而存在，随着类的消失而消失。 调用方式不同 成员变量只能被对象调用。静态变量可以被对象调用，还可以被类名调用。 别名不同 ​成员变量也称为实例变量。 静态变量也称为类变量。 数据存储位置不同 ​成员变量存储在堆内存的对象中，所以也叫对象的特有数据。静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。 静态方法当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。 类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。 定义格式： 修饰符 static 返回值类型 方法名 (参数列表){ // 执行语句 }调用注意事项 静态方法可以直接访问类变量和静态方法。 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。 静态方法中，不能使用this关键字。 tip:静态方法只能访问静态成员调用格式被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。格式： // 访问类变量 类名.类变量名； // 调用静态方法 类名.静态方法名(参数)； tip:static 修饰的内容： 是随着类的加载而加载的，且只加载一次。 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。 静态代码块定义在成员位置，使用static修饰的代码块{ }。 位置：类中方法外。 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。格式：public class ClassName{ static { // 执行语句 } } 作用：给类变量进行初始化赋值实例：public class Game { public static int number; public static ArrayList&lt;String&gt; list; static { // 给类变量赋值 number = 2; list = new ArrayList&lt;String&gt;(); // 添加元素到集合中 list.add(\"a\"); list.add(\"b\"); } } tips:static 关键字，可以修饰变量、方法和代码块。在使用的过程中，**其主要目的还是想在不创建对象的情况下，去调用方法。** Arrays类概述java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。**其所有方法均为静态方法**，调用起来非常简单。 常用的方法 public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。 public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。 Math类概述java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 常用的方法 public static double abs(double a) ：返回 double 值的绝对值。 public static double floor(double a) ：返回小于等于参数最大的整数。 public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法） 继承概述定义： 就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。优点： 提高代码的复用性。 类与类之间产生了关系，是多态的前提。 格式： class 父类 { ... } class 子类 extends 父类 { ... } 继承后的特点——成员变量 成员变量不重名如果子类父类中出现不重名的成员变量，这时的访问是没有影响的 成员变量重名如果子类父类中出现重名的成员变量，这时的访问是有影响的,子类成员变量将父类的覆盖。 子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用super关键字，修饰父类成员变量，类似于this。使用格式： super.父类成员变量名 tip:父类中的成员变量是非私有的，子类中可以直接访问。若父类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？可以在父类中提供公共的getXxx方法和setXxx方法。 继承后的特点——成员方法 成员方法不重名如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。 成员方法重名如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。 重写： 子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写优点：子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。例子： class Phone { public void sendMessage(){ System.out.println(\"发短信\"); } public void call(){ System.out.println(\"打电话\"); } public void showNum(){ System.out.println(\"来电显示号码\"); } } //智能手机类 class NewPhone extends Phone { //重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能 public void showNum(){ //调用父类已经存在的功能使用super super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println(\"显示来电姓名\"); System.out.println(\"显示头像\"); } } tip：这里重写时，用到super.父类成员方法，表示调用父类的成员方法 继承后的特点——构造方法 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。继承的类型抽象类概述父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 abstract使用格式抽象方法 使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。定义： 修饰符 abstract 返回值类型 方法名 (参数列表)； 抽象类如果一个类包含抽象方法，那么该类必须是抽类。 定义格式： abstract class 类名字 { } 抽象类的使用继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 接口概述接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。 接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。 引用数据类型：数组，类，接口。 接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 定义格式public interface 接口名称 { // 抽象方法 // 默认方法 // 静态方法 // 私有方法 } 含有抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。 含有默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。 含有静态方法：使用 static 修饰，供接口直接调用。 含有私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。 基本的实现类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。非抽象子类实现接口： 必须重写接口中所有抽象方法。 继承了接口的默认方法，即可以直接调用，也可以重写。实现格式：class 类名 implements 接口名 { // 重写接口中抽象方法【必须】 // 重写接口中默认方法【可选】 } 抽象方法的使用 必须全部实现，代码如下： 定义接口： public interface LiveAble { // 定义抽象方法 public abstract void eat(); public abstract void sleep(); } 定义实现类： public class Animal implements LiveAble { @Override public void eat() { System.out.println(\"吃东西\"); } @Override public void sleep() { System.out.println(\"晚上睡\"); } } 定义测试类： public class InterfaceDemo { public static void main(String[] args) { // 创建子类对象 Animal a = new Animal(); // 调用实现后的方法 a.eat(); a.sleep(); } } 输出结果： 吃东西 晚上睡 默认方法的使用可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 继承默认方法，代码如下：定义接口：public interface LiveAble { public default void fly(){ System.out.println(\"天上飞\"); } } 定义实现类: public class Animal implements LiveAble { // 继承，什么都不用写，直接调用 } 定义测试类：public class InterfaceDemo { public static void main(String[] args) { // 创建子类对象 Animal a = new Animal(); // 调用默认方法 a.fly(); } } 输出结果： 天上飞 重写默认方法，代码如下：定义接口：public interface LiveAble { public default void fly(){ System.out.println(\"天上飞\"); } } 定义实现类:public class Animal implements LiveAble { @Override public void fly() { System.out.println(\"自由自在的飞\"); } } 定义测试类：public class InterfaceDemo { public static void main(String[] args) { // 创建子类对象 Animal a = new Animal(); // 调用重写方法 a.fly(); } } 输出结果： 自由自在的飞 静态方法的使用静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用，代码如下：定义接口： public interface LiveAble { public static void run(){ System.out.println(\"跑起来~~~\"); } } 定义实现类： public class Animal implements LiveAble { // 无法重写静态方法 } 定义测试类： public class InterfaceDemo { public static void main(String[] args) { // Animal.run(); // 【错误】无法继承方法,也无法调用 LiveAble.run(); // } } 输出结果： 跑起来~~~ 私有方法的使用 私有方法：只有默认方法可以调用。 私有静态方法：默认方法和静态方法可以调用。 如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法 去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。 定义接口： public interface LiveAble { default void func(){ func1(); func2(); } private void func1(){ System.out.println(\"跑起来~~~\"); } private void func2(){ System.out.println(\"跑起来~~~\"); } } 接口的多实现在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。实现格式：class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... { // 重写接口中抽象方法【必须】 // 重写接口中默认方法【不重名时可选】 } 抽象方法接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。代码如下：定义多个接口： interface A { public abstract void showA(); public abstract void show(); } interface B { public abstract void showB(); public abstract void show(); } 定义实现类： public class C implements A,B{ @Override public void showA() { System.out.println(\"showA\"); } @Override public void showB() { System.out.println(\"showB\"); } @Override public void show() { System.out.println(\"show\"); } } 默认方法 接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。代码如下：定义多个接口： interface A { public default void methodA(){} public default void method(){} } interface B { public default void methodB(){} public default void method(){} } 定义实现类： public class C implements A,B{ @Override public void method() { System.out.println(\"method\"); } } 静态方法接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。优先级的问题当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下：定义接口： interface A { public default void methodA(){ System.out.println(\"AAAAAAAAAAAA\"); } } 定义父类： class D { public void methodA(){ System.out.println(\"DDDDDDDDDDDD\"); } } 定义子类： class C extends D implements A { // 未重写methodA方法 } 定义测试类： public class Test { public static void main(String[] args) { C c = new C(); c.methodA(); } } 输出结果: DDDDDDDDDDDD 接口的多继承一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。代码如下： 定义父接口： interface A { public default void method(){ System.out.println(\"AAAAAAAAAAAAAAAAAAA\"); } } interface B { public default void method(){ System.out.println(\"BBBBBBBBBBBBBBBBBBB\"); } } 定义子接口： interface D extends A,B{ @Override public default void method() { System.out.println(\"DDDDDDDDDDDDDD\"); } } tips：子接口重写默认方法时，default关键字可以保留。子类重写默认方法时，default关键字不可以保留。 接口与类的相似点和区别相似点 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中 接口与类的区别 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。接口的特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 多态概述多态是继封装、继承之后，面向对象的第三大特性。生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。定义： 多态：是指同一行为，具有多个不同表现形式。前提： 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 多态的体现格式： 父类类型 变量名 = new 子类对象； 变量名.方法名(); 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 代码如下: Fu f = new Zi(); f.method(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。 代码如下：定义父类： ```java public abstract class Animal { public abstract void eat(); } 定义子类： class Cat extends Animal { public void eat() { System.out.println(\"吃鱼\"); } } class Dog extends Animal { public void eat() { System.out.println(\"吃骨头\"); } } 定义测试类： public class Test { public static void main(String[] args) { // 多态形式，创建对象 Animal a1 = new Cat(); // 调用的是 Cat 的 eat a1.eat(); // 多态形式，创建对象 Animal a2 = new Dog(); // 调用的是 Dog 的 eat a2.eat(); } } 多态的好处实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下： 定义父类： public abstract class Animal { public abstract void eat(); } 定义子类： class Cat extends Animal { public void eat() { System.out.println(\"吃鱼\"); } } class Dog extends Animal { public void eat() { System.out.println(\"吃骨头\"); } } 定义测试类： public class Test { public static void main(String[] args) { // 多态形式，创建对象 Cat c = new Cat(); Dog d = new Dog(); // 调用showCatEat showCatEat(c); // 调用showDogEa showDogEat(d); /* 以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代 而执行效果一致 */ showAnimalEat(c); showAnimalEat(d); } public static void showCatEat (Cat c){ c.eat(); } public static void showDogEat (Dog d){ d.eat(); } public static void showAnimalEat (Animal a){ a.eat(); } } 由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。 引用类型的转换多态的转型分为向上转型和向下转型向上转型 向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。 使用格式： 父类类型 变量名 = new 子类类型(); 如：Animal a = new Cat(); 向下转型 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。使用格式：子类类型 变量名 = (子类类型) 父类变量名; 如:Cat c =(Cat) a; 为什么要转型当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 转型演示，代码如下：定义类 abstract class Animal { abstract void eat(); } class Cat extends Animal { public void eat() { System.out.println(\"吃鱼\"); } public void catchMouse() { System.out.println(\"抓老鼠\"); } } class Dog extends Animal { public void eat() { System.out.println(\"吃骨头\"); } public void watchHouse() { System.out.println(\"看家\"); } } 定义测试类： public class Test { public static void main(String[] args) { // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse } } 转型的异常转型的过程中，遇到的问题： public class Test { public static void main(String[] args) { // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】 } } 这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 变量名 instanceof 数据类型 如果变量属于该数据类型，返回true。 如果变量不属于该数据类型，返回false。 所以转换之前最好进行判断： public class Test { public static void main(String[] args) { // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat){ Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse } else if (a instanceof Dog){ Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse } } } final关键字概述学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了final 关键字，用于修饰不可改变内容。 final:不可改变，可用于修饰类，方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，不能被重新赋值。 使用方式修饰类 final class 类名 { } 修饰方法 修饰符 final 返回值类型 方法名(参数列表){ //方法体 } 修饰变量 权限修饰符概述在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限， public：公共的。 protected：受保护的 default：默认的 private：私有的不同访问权限的访问能力 public protected default private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 可见，public具有最大权限。private则是最小权限。编写代码时，如果没有特殊的考虑，建议这样使用权限： 成员变量使用 private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用 public ，方便调用方法 tip:不加权限修饰符，其访问能力与default修饰符相同 内部类概述将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。成员内部类 成员内部类 ：定义在类中方法外的类。 格式： class 外部类 { class 内部类{ } } 在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。例如： lass Car { //外部类 class Engine { //内部类 } } 访问特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。创建内部类对象格式：外部类名.内部类名 对象名 = new 外部类型().new 内部类型()； 访问演示如下：定义类：public class Person { private boolean live = true; class Heart { public void jump() { // 直接访问外部类成员 if (live) { System.out.println(\"心脏在跳动\"); } else { System.out.println(\"心脏不跳了\"); } } } public boolean isLive() { return live; } public void setLive(boolean live) { this.live = live; } } 定义测试类：public class InnerDemo { public static void main(String[] args) { // 创建外部类对象 Person p = new Person(); // 创建内部类对象 Heart heart = p.new Heart(); // 调用内部类方法 heart.jump(); // 调用外部类方法 p.setLive(false); // 调用内部类方法 heart.jump(); } } 输出结果: 心脏在跳动 心脏不跳了 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，Person$Heart.class 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。class People{ public People() { } } class Man{ public Man(){ } public People getWoman(){ class Woman extends People{ //局部内部类 int age =0; } return new Woman(); } } 注意：局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。 匿名内部类 匿名内部类：是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作， 定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。前提 匿名内部类必须继承一个父类或者实现一个父接口。格式 new 父类名或者接口名(){ // 方法重写 @Override public void method() { // 执行语句 } }; 使用方式以抽象类为例，匿名内部类的使用，代码如下：定义抽象类： public abstract class FlyAble{ public abstract void fly(); } 创建匿名内部类，并调用： public class InnerDemo { public static void main(String[] args) { /* 1.等号右边:是匿名内部类，定义并创建该接口的子类对象 2.等号左边:是多态赋值,接口类型引用指向子类对象 */ FlyAble f = new FlyAble(){ public void fly() { System.out.println(\"我飞了~~~\"); } }; //调用 fly方法,执行重写后的方法 f.fly(); } } 通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下： public class InnerDemo2 { public static void main(String[] args) { /* 1.等号右边:定义并创建该接口的子类对象 2.等号左边:是多态,接口类型引用指向子类对象 */ FlyAble f = new FlyAble(){ public void fly() { System.out.println(\"我飞了~~~\"); } }; // 将f传递给showFly方法中 showFly(f); } public static void showFly(FlyAble f) { f.fly(); } } 以上两步，也可以简化为一步，代码如下： ```java public class InnerDemo3 { public static void main(String[] args) { /* 创建匿名内部类,直接传递给showFly(FlyAble f) */ showFly( new FlyAble(){ public void fly() { System.out.println(\"我飞了~~~\"); } }); } public static void showFly(FlyAble f) { f.fly(); } } 引用类型用法总结class作为成员变量在定义一个Role（游戏角色）时，代码如下： class Role { int id; // 角色id int blood; // 生命值 String name; // 角色名称 } object类概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： public class MyClass /*extends Object*/ { // ... } 几个重要的方法 1.toString方法：返回该对象的字符串表 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。一般是用覆盖重写 覆盖重写：如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： public class Person { private String name; private int age; @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } // 省略构造器与Getter Setter } equals方法：指示其他某个对象是否与此对象“相等”。如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： import java.util.Objects; public class Person { private String name; private int age; @Override public boolean equals(Object o) { // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); } } 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： 时间日期类Date类 java.util.Date类 表示特定的瞬间，精确到毫秒 常用方法:Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法 由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： import java.text.DateFormat; import java.text.SimpleDateFormat; public class Demo02SimpleDateFormat { public static void main(String[] args) { // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); } } 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法 使用format方法的代码为： import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; /* 把Date对象转换成String */ public class Demo03DateFormatMethod { public static void main(String[] args) { Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); } parse方法 使用parse方法的代码为： import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /* 把String转换成Date对象 */ public class Demo04DateFormatMethod { public static void main(String[] args) throws ParseException { DateFormat dh = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str2 = \"2021年6月11日\"; Date date1 = dh.parse(str2); System.out.println(date); // } } Calendar类概念java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： import java.util.Calendar; public class Demo06CalendarInit { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); } } 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： import java.util.Calendar; public class CalendarUtil { public static void main(String[] args) { // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); } } import java.util.Calendar; public class Demo07CalendarMethod { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 } } add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： import java.util.Calendar; public class Demo08CalendarMethod { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); } } getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 import java.util.Calendar; import java.util.Date; public class Demo09CalendarMethod { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); } } Tip： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。","categories":[{"name":"语言篇","slug":"语言篇","permalink":"http://inactionzz.github.io/categories/%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://inactionzz.github.io/tags/JAVA/"}],"author":"ZZ"}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://inactionzz.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"语言篇","slug":"语言篇","permalink":"http://inactionzz.github.io/categories/%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://inactionzz.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"http://inactionzz.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://inactionzz.github.io/tags/Github/"},{"name":"Python","slug":"Python","permalink":"http://inactionzz.github.io/tags/Python/"},{"name":"JAVA","slug":"JAVA","permalink":"http://inactionzz.github.io/tags/JAVA/"}]}